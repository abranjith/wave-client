<!-- Generated by spec-lite v0.0.4 | sub-agent: feature | date: 2026-02-21 -->

# Feature: ArenaService

## 1. Feature Goal

**ID**: FEAT-002

Implement `ArenaService` — the VS Code extension-host service that wires up the real
LangGraph-powered agents from `@wave-client/arena` to handle Arena AI chat requests.
It receives an `ArenaChatRequest`, selects and caches the correct agent, drives the
streaming `AsyncGenerator<ChatChunk>` render loop, converts chunks to
`ArenaChatStreamChunk`, and delivers a final `ArenaChatResponse`. It also exposes
`validateApiKey` and `getAvailableModels` for provider configuration.

This unblocks FEAT-003 (message handlers) and FEAT-004 (vsCodeArenaAdapter update),
which both route through `arenaService`.

---

## 2. Data Model (Granular)

### Entities & Attributes

**`ArenaChatRequest`** (from `@wave-client/core`):
- `sessionId` (`string`) — UUID of the owning session. NOT NULL.
- `message` (`string`) — User message text. NOT NULL.
- `command?` (`ArenaCommandId`) — Optional slash command that triggered the request.
- `agent` (`ArenaAgentId`) — Which agent: `'wave-client'` | `'web-expert'`. NOT NULL.
- `history` (`ArenaMessage[]`) — Messages from the session prior to the new one. NOT NULL.
- `settings` (`ArenaSettings`) — Provider, model, streaming flag, etc. NOT NULL.

**`ArenaChatStreamChunk`** (from `@wave-client/core`):
- `messageId` (`string`) — UUID of the assistant message being built. NOT NULL.
- `content` (`string`) — Incremental text delta or full content on `done`. NOT NULL.
- `done` (`boolean`) — `true` on the final chunk. NOT NULL.
- `sources?` (`ArenaMessageSource[]`) — Populated on the final chunk for web-expert.
- `tokenCount?` (`number`) — Populated on the final chunk.
- `blocks?` (`ArenaChatBlock[]`) — Rich UI blocks; not yet populated by agents.

**`ArenaChatResponse`** (from `@wave-client/core`):
- `messageId` (`string`) — UUID, matches the streaming `messageId`.
- `content` (`string`) — Full accumulated response text.
- `sources?` (`ArenaMessageSource[]`) — From web-expert agent.
- `tokenCount?` (`number`) — Total tokens used.
- `blocks?` (`ArenaChatBlock[]`) — Rich UI blocks.

**`ChatChunk`** (from `@wave-client/arena`):
- `id` (`string`) — Random ID for the chunk itself; NOT the message ID.
- `messageId` (`string`) — UUID of the assistant message being built.
- `content` (`string`) — Text delta. Empty for tool-call chunks.
- `done` (`boolean`) — `true` on the sentinel chunk.
- `toolCall?` (`{ name: string; arguments?: string }`) — Set when the agent calls a tool. Only on intermediate chunks; those chunks have `content: ''`.
- `error?` (`string`) — Set on error sentinel chunks from `webExpertAgent`.

**`LLMProviderConfig`** (from `@wave-client/arena`):
- `GeminiConfig { provider: 'gemini', apiKey: string, model?: string }`
- `OllamaConfig { provider: 'ollama', baseUrl: string, model?: string }`
- (openai / anthropic / azure-openai exist in the union but `createProviderFactory` throws for them)

**`AgentCacheKey`** (internal):
- Pattern: `` `${provider}:${model ?? 'default'}:${agentId}` ``
- Used to avoid recompiling LangGraph state graphs on every request.

### Type Bridge: `ArenaMessage` → `ChatMessage`

`ArenaChatRequest.history` holds `ArenaMessage[]` (core type). The agent expects
`ChatMessage[]` (arena package type). Conversion:

| `ArenaMessage` field | → `ChatMessage` field |
|---|---|
| `id` | `id` |
| `role` | `role` |
| `content` | `content` |
| `timestamp` | `timestamp` |
| `tokenCount?` | `tokenCount?` |
| `sessionId`, `status`, `command`, `error`, `sources`, `blocks` | _(dropped)_ |

Only messages with `role: 'user'` or `role: 'assistant'` are forwarded (tool/system
messages are not expected in the public history array but should be filtered defensively).

### Type Bridge: `ChatChunk` → `ArenaChatStreamChunk`

| `ChatChunk` field | → `ArenaChatStreamChunk` field |
|---|---|
| `messageId` | `messageId` |
| `content` | `content` |
| `done` | `done` |
| `tokenCount?` | `tokenCount?` |
| `toolCall` | _(silently skipped; tool-call chunks have `content: ''` so no text is lost)_ |
| `error` | _(forwarded as content on done chunk with error prefix; see streaming loop)_ |

### Provider Settings Resolution

When building `LLMProviderConfig`, the service calls
`arenaStorageService.loadProviderSettings()` (FEAT-001) to retrieve stored API keys and
base URLs. Active provider comes from `request.settings.provider`; active model from
`request.settings.model` (falls back to provider default).

Resolution priority:
```
providerSettings[provider].apiKey   → GeminiConfig.apiKey
providerSettings[provider].apiUrl   → OllamaConfig.baseUrl (falls back to OLLAMA_DEFAULT_BASE_URL)
request.settings.model              → model override
```

If the stored API key is absent or empty for a cloud provider, throw a descriptive error
before constructing the agent.

---

## 3. Files

- `packages/vscode/package.json` — **Update** — add `"@wave-client/arena": "workspace:*"` to `dependencies`
- `packages/vscode/src/services/ArenaService.ts` — **Create** — the service class + singleton
- `packages/vscode/src/services/index.ts` — **Update** — export `ArenaService` and `arenaService` singleton
- `packages/vscode/src/test/services/ArenaService.test.ts` — **Create** — unit tests

---

## 4. Dependencies

- **FEAT-001** (`ArenaStorageService` in `@wave-client/shared`) must be complete; `arenaService`
  calls `arenaStorageService.loadProviderSettings()` and `arenaStorageService.loadSettings()`.
- `@wave-client/arena` — add as workspace dep; provides `createWaveClientAgent`,
  `createWebExpertAgent`, `createProviderFactory`, `LLMProviderConfig`, `ChatMessage`, `ChatChunk`.
- `@wave-client/core` — already a dep; provides `ArenaChatRequest`, `ArenaChatResponse`,
  `ArenaChatStreamChunk`, `ArenaMessage`, `ArenaSettings`, `ArenaAgentId`, `ARENA_AGENT_IDS`,
  `getModelsForProvider`, `geminiModelsUrl`, `ollamaTagsUrl`, `OLLAMA_DEFAULT_BASE_URL`.
- `@wave-client/shared` — already a dep; provides `arenaStorageService`.

---

## 5. Implementation Tasks

---

### TASK-001: Add `@wave-client/arena` workspace dependency

- [x] **Implementation**:
  In `packages/vscode/package.json`, add to the `"dependencies"` section:
  ```json
  "@wave-client/arena": "workspace:*"
  ```
  Run `pnpm install` from the repo root to link the workspace package.

- [x] **Unit Tests**: N/A — dependency change only.

- [x] **Documentation Update**: N/A.

- **Verify**: `pnpm --filter @wave-client/vscode build` succeeds after the install.

---

### TASK-002: Implement `ArenaService` — core class, provider wiring, agent caching

- [x] **Implementation**:
  Create `packages/vscode/src/services/ArenaService.ts`.

  #### Class skeleton

  ```typescript
  import { createProviderFactory, createWaveClientAgent, createWebExpertAgent } from '@wave-client/arena';
  import type { LLMProviderConfig, ChatMessage } from '@wave-client/arena';
  import type {
    ArenaChatRequest, ArenaChatResponse, ArenaChatStreamChunk,
    ArenaMessage, ArenaAgentId
  } from '@wave-client/core';
  import { ARENA_AGENT_IDS, OLLAMA_DEFAULT_BASE_URL } from '@wave-client/core';
  import { arenaStorageService } from '@wave-client/shared';

  type CachedAgent = {
    chat(history: ChatMessage[], message: string): AsyncGenerator<ChatChunk>;
  };

  export class ArenaService {
    /** Reuse compiled LangGraph graphs across requests. */
    private agentCache = new Map<string, CachedAgent>();

    async streamChat(
      request: ArenaChatRequest,
      onChunk: (chunk: ArenaChatStreamChunk) => void,
      signal?: AbortSignal,
    ): Promise<ArenaChatResponse> { ... }

    async validateApiKey(
      provider: ArenaProviderType,
      providerSettings: ArenaProviderSettings,
    ): Promise<{ valid: boolean; error?: string }> { ... }

    async getAvailableModels(
      provider: ArenaProviderType,
      providerSettings: ArenaProviderSettings,
    ): Promise<ModelDefinition[]> { ... }

    private async buildProviderConfig(request: ArenaChatRequest): Promise<LLMProviderConfig> { ... }
    private async getOrCreateAgent(request: ArenaChatRequest, llm: BaseChatModel): Promise<CachedAgent> { ... }
    private buildCacheKey(request: ArenaChatRequest): string { ... }
    private convertHistory(history: ArenaMessage[]): ChatMessage[] { ... }
  }

  export const arenaService = new ArenaService();
  ```

  #### `buildProviderConfig(request)`

  1. Call `arenaStorageService.loadProviderSettings()` to get storedSettings.
  2. Extract `provider = request.settings.provider` and `model = request.settings.model`.
  3. Retrieve `providerSettings = storedSettings[provider]`.
  4. Switch on `provider`:
     - `'gemini'`: require `providerSettings?.apiKey` (throw `Error('Gemini API key is not configured')` if missing); return `{ provider: 'gemini', apiKey, model }`.
     - `'ollama'`: return `{ provider: 'ollama', baseUrl: providerSettings?.apiUrl ?? OLLAMA_DEFAULT_BASE_URL, model }`.
     - default: throw `Error(\`Provider '${provider}' is not supported\`)`.
  5. Omit `model` from the config object when it is `undefined` (avoid passing `model: undefined`).

  #### `getOrCreateAgent(request, llm)`

  1. Compute `cacheKey = buildCacheKey(request)`.
  2. If `agentCache.has(cacheKey)`, return the cached agent.
  3. Switch on `request.agent`:
     - `ARENA_AGENT_IDS.WAVE_CLIENT`: create agent via `createWaveClientAgent({ llm })`.
     - `ARENA_AGENT_IDS.WEB_EXPERT`: create agent via `createWebExpertAgent({ llm })`.
     - default: throw `Error(\`Unknown agent: ${request.agent}\`)`.
  4. Cache and return the agent.

  #### `buildCacheKey(request)`

  ```typescript
  private buildCacheKey(request: ArenaChatRequest): string {
    const { provider, model } = request.settings;
    return `${provider}:${model ?? 'default'}:${request.agent}`;
  }
  ```

  #### `convertHistory(history)`

  ```typescript
  private convertHistory(history: ArenaMessage[]): ChatMessage[] {
    return history
      .filter((m) => m.role === 'user' || m.role === 'assistant')
      .map((m) => ({
        id: m.id,
        role: m.role,
        content: m.content,
        timestamp: m.timestamp,
        ...(m.tokenCount !== undefined && { tokenCount: m.tokenCount }),
      }));
  }
  ```

  #### `streamChat(request, onChunk, signal?)`

  ```
  1. Call buildProviderConfig(request) → providerConfig.
  2. Call createProviderFactory(providerConfig) → llm.
  3. Call getOrCreateAgent(request, llm) → agent.
  4. Convert history: chatHistory = convertHistory(request.history).
  5. Generate a stable messageId = crypto.randomUUID().
  6. Initialise accumulator: let accContent = ''.
  7. Obtain the AsyncGenerator: gen = agent.chat(chatHistory, request.message).
  8. Iterate:
     for await (const chunk of gen) {
       if (signal?.aborted) break;
       if (chunk.error) {
         // surface error as content on the final emit, then break
         accContent += `\n[Error: ${chunk.error}]`;
         onChunk({ messageId, content: accContent, done: true });
         break;
       }
       if (chunk.toolCall) continue;  // silent; text result follows in later chunks
       accContent += chunk.content;
       onChunk({ messageId, content: chunk.content, done: chunk.done });
       if (chunk.done) break;
     }
  9. If signal?.aborted and not yet done:
       onChunk({ messageId, content: accContent, done: true });
  10. Return { messageId, content: accContent }.
  ```

  **Notes on streaming**:
  - Emit `content: chunk.content` (the _delta_) on non-done chunks, not the accumulated string.
  - The final `done: true` chunk from the agent already has `content: ''` per the agent spec, so
    the accumulator is the source of truth for the final response.
  - `tokenCount` is not yet emitted by the arena agents; leave `tokenCount` off the response.

- [x] **Unit Tests**: Covered in TASK-005.

- [x] **Documentation Update**:
  Add class-level JSDoc describing the caching strategy and provider support.
  Add `@param`/`@returns` JSDoc to all public methods.

---

### TASK-003: Implement `validateApiKey` and `getAvailableModels`

- [x] **Implementation**:
  Add two methods directly on `ArenaService` (same file as TASK-002).

  #### `validateApiKey(provider, providerSettings)`

  Issues a lightweight HTTP probe using the global `fetch` (not `HttpService`) to keep this
  path free of dependency on the HTTP request plumbing:

  ```typescript
  async validateApiKey(
    provider: ArenaProviderType,
    providerSettings: ArenaProviderSettings,
  ): Promise<{ valid: boolean; error?: string }> {
    try {
      if (provider === 'gemini') {
        const apiKey = providerSettings.apiKey ?? '';
        if (!apiKey) return { valid: false, error: 'API key is empty' };
        const res = await fetch(geminiModelsUrl(apiKey));
        return res.ok
          ? { valid: true }
          : { valid: false, error: `Gemini returned status ${res.status}` };
      }

      if (provider === 'ollama') {
        const baseUrl = providerSettings.apiUrl ?? OLLAMA_DEFAULT_BASE_URL;
        const res = await fetch(ollamaTagsUrl(baseUrl));
        return res.ok
          ? { valid: true }
          : { valid: false, error: `Ollama returned status ${res.status}` };
      }

      return { valid: false, error: `Provider '${provider}' validation is not supported` };
    } catch (err) {
      return { valid: false, error: err instanceof Error ? err.message : String(err) };
    }
  }
  ```

  #### `getAvailableModels(provider, providerSettings)`

  - For `'ollama'`: probe `{baseUrl}/api/tags` (same endpoint as validation); if reachable,
    parse the JSON response body (`{ models: { name: string }[] }`) and map each model
    name to a `ModelDefinition`-compatible object `{ id: name, label: name, provider: 'ollama' }`.
    On fetch failure, fall back to the static `getModelsForProvider('ollama')` list.
  - For all other providers: return `getModelsForProvider(provider)` (static list from core).

  ```typescript
  async getAvailableModels(
    provider: ArenaProviderType,
    providerSettings: ArenaProviderSettings,
  ): Promise<ModelDefinition[]> {
    if (provider === 'ollama') {
      try {
        const baseUrl = providerSettings.apiUrl ?? OLLAMA_DEFAULT_BASE_URL;
        const res = await fetch(ollamaTagsUrl(baseUrl));
        if (res.ok) {
          const data = (await res.json()) as { models: { name: string }[] };
          return (data.models ?? []).map((m) => ({
            id: m.name,
            label: m.name,
            provider: 'ollama' as const,
            contextWindow: 0,
          }));
        }
      } catch {
        // fall through to static list
      }
    }
    return getModelsForProvider(provider);
  }
  ```

- [x] **Unit Tests**: Covered in TASK-005.

- [x] **Documentation Update**:
  Add `@param`/`@returns` JSDoc, note that `fetch` is used directly (not `HttpService`).

---

### TASK-004: Export `arenaService` singleton from `packages/vscode/src/services/index.ts`

- [x] **Implementation**:
  Add the following line to the VS Code-specific services section of
  `packages/vscode/src/services/index.ts`:

  ```typescript
  export { ArenaService, arenaService } from './ArenaService';
  ```

  Place this export after the `SecurityService` export, grouped under a comment:
  ```typescript
  // Arena services
  export { ArenaService, arenaService } from './ArenaService';
  ```

- [x] **Unit Tests**: N/A — barrel export.

- [x] **Documentation Update**: N/A.

- **Verify**: `pnpm --filter @wave-client/vscode build` succeeds.

---

### TASK-005: Unit tests for `ArenaService`

- [x] **Implementation**:
  Create `packages/vscode/src/test/services/ArenaService.test.ts`.

  Follow the same mock pattern as `SecurityService.test.ts`: use Vitest, mock `@wave-client/arena`,
  mock `@wave-client/shared`, mock `@wave-client/core` constants/functions as needed.

  #### Mock setup

  ```typescript
  import { describe, it, expect, vi, beforeEach } from 'vitest';

  // --- mock @wave-client/arena ---
  const mockChatFn = vi.fn();
  const mockWaveClientAgent = { chat: mockChatFn };
  const mockWebExpertAgent = { chat: mockChatFn };

  vi.mock('@wave-client/arena', () => ({
    createWaveClientAgent: vi.fn(() => mockWaveClientAgent),
    createWebExpertAgent: vi.fn(() => mockWebExpertAgent),
    createProviderFactory: vi.fn(() => ({})),  // returns fake BaseChatModel
  }));

  // --- mock @wave-client/shared ---
  const mockLoadProviderSettings = vi.fn();
  vi.mock('@wave-client/shared', () => ({
    arenaStorageService: {
      loadProviderSettings: mockLoadProviderSettings,
    },
  }));
  ```

  #### Helper: fake async generator

  ```typescript
  async function* makeChunks(chunks: Partial<ChatChunk>[]) {
    for (const c of chunks) {
      yield { id: 'c1', messageId: 'msg-1', content: '', done: false, ...c };
    }
  }
  ```

  #### Test cases

  **`streamChat` — agent selection**:
  - When `request.agent === ARENA_AGENT_IDS.WAVE_CLIENT`, asserts that
    `createWaveClientAgent` was called and `createWebExpertAgent` was NOT called.
  - When `request.agent === ARENA_AGENT_IDS.WEB_EXPERT`, asserts the reverse.

  **`streamChat` — chunk forwarding**:
  - Provide generator yielding `[{content:'Hello'}, {content:' World', done:true}]`.
  - Assert `onChunk` is called twice; first call has `{ content:'Hello', done:false }`,
    second has `{ content:' World', done:true }`.
  - Assert returned `ArenaChatResponse.content === 'Hello World'`.

  **`streamChat` — tool-call chunks are skipped**:
  - Provide generator yielding `[{toolCall:{name:'search'}, content:''}, {content:'answer', done:true}]`.
  - Assert `onChunk` is called only once (the tool-call chunk is silently skipped).
  - Assert `content === 'answer'` in the final response.

  **`streamChat` — AbortSignal**:
  - Set `signal.aborted = true` before iteration.
  - Assert `onChunk` is called once with `done:true` immediately.
  - Assert returned `content` is `''` (no chunks consumed).

  **`streamChat` — missing Gemini API key throws**:
  - `mockLoadProviderSettings` returns `{ gemini: { enabled: true } }` (no apiKey).
  - Assert `streamChat()` rejects with `/Gemini API key/i`.

  **`streamChat` — unsupported provider throws**:
  - `request.settings.provider = 'openai'`.
  - Assert `streamChat()` rejects with `/not supported/i`.

  **`streamChat` — agent is cached on second call**:
  - Call `streamChat` twice with identical request settings.
  - Assert `createWaveClientAgent` is called exactly once (second call hits the cache).

  **`validateApiKey` — gemini valid key**:
  - Mock global `fetch` to return `{ ok: true }`.
  - Assert result is `{ valid: true }`.

  **`validateApiKey` — gemini empty key**:
  - `providerSettings.apiKey = ''`.
  - Assert result is `{ valid: false, error: 'API key is empty' }` without calling `fetch`.

  **`validateApiKey` — gemini bad status**:
  - Mock `fetch` to return `{ ok: false, status: 401 }`.
  - Assert `valid: false` and `error` contains `401`.

  **`validateApiKey` — ollama reachable**:
  - Mock `fetch` to return `{ ok: true }`.
  - Assert result is `{ valid: true }`.

  **`validateApiKey` — fetch throws**:
  - Mock `fetch` to throw `new Error('ECONNREFUSED')`.
  - Assert `valid: false` and `error` contains `ECONNREFUSED`.

  **`getAvailableModels` — ollama live fetch success**:
  - Mock `fetch` to return `{ ok: true, json: async () => ({ models: [{ name: 'llama3' }] }) }`.
  - Assert returned list contains `{ id: 'llama3', label: 'llama3', provider: 'ollama' }`.

  **`getAvailableModels` — ollama live fetch fails, falls back to static**:
  - Mock `fetch` to throw.
  - Assert list equals `getModelsForProvider('ollama')` (non-empty).

  **`getAvailableModels` — gemini returns static list**:
  - Assert list equals `getModelsForProvider('gemini')`.

- [x] **Documentation Update**: N/A — test file is self-documenting.

- **Verify**: `pnpm --filter @wave-client/vscode test` passes with all new test cases green.

---

## 6. Cross-Cutting Concerns

### Error Handling

- `buildProviderConfig` throws synchronously for unsupported providers and missing required API
  keys. Callers (message handlers in FEAT-003) catch and return a `streamError` postMessage.
- `validateApiKey` and `getAvailableModels` do NOT throw; they return structured results or
  safe fallbacks. This keeps the webview settings UI non-crashing even when providers are offline.
- Streaming errors from agents (`ChatChunk.error`) are folded into the `done` chunk content as
  `[Error: ...]` so the webview always receives a terminal chunk.

### `AbortSignal` / Cancellation

- `streamChat` accepts an optional `AbortSignal`. When `signal.aborted` is true at iteration
  start, emit a single `done: true` chunk and return immediately without touching the generator.
- During iteration, check `signal?.aborted` before processing each chunk; if true, emit a final
  `done: true` chunk and `break`.
- The generator is not explicitly closed (`return()` not called) because LangGraph handles
  cleanup internally when iteration stops.

### Agent Caching

- The `agentCache` Map lives for the lifetime of the `ArenaService` singleton (i.e., the
  extension host session). An agent is cached by `"${provider}:${model ?? 'default'}:${agentId}"`.
- Cache invalidation is not implemented in this feature; it will be addressed when provider
  settings change events are wired up in FEAT-003/004.
- Cached agents are safe to reuse because `createWaveClientAgent`/`createWebExpertAgent` are
  stateless factories; state lives in the LangGraph execution context, not the agent object.

### Provider Support Scope

- Only `'gemini'` and `'ollama'` are wired (matching `createProviderFactory` in the arena
  package). `'openai'`, `'anthropic'`, `'azure-openai'`, and `'copilot'` will throw
  `Error("Provider '...' is not supported")` — the message handler converts this to a user-
  facing error notification.
- Adding new providers in the future requires only: update `buildProviderConfig` switch and
  `createProviderFactory` in `@wave-client/arena`.

### Platform Independence

- `ArenaService` is a Node.js-only service (LangGraph agents use `readFileSync`,
  `langchain/core`, etc.). It must never be imported by `packages/core` or `packages/web`.
- It must only be referenced from `packages/vscode`.

---

## 7. State Tracking

```
[FEAT-002]  ArenaService
  [TASK-001] Add @wave-client/arena dep to vscode/package.json   [ ] not-started
  [TASK-002] Core ArenaService class, provider wiring, caching   [ ] not-started
  [TASK-003] validateApiKey + getAvailableModels                  [ ] not-started
  [TASK-004] Export arenaService from services/index.ts           [ ] not-started
  [TASK-005] Unit tests for ArenaService                          [ ] not-started
```
