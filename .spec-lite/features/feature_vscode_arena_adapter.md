<!-- Generated by spec-lite v0.0.4 | sub-agent: feature | date: 2026-02-21 -->

# Feature: Updated vsCodeArenaAdapter

## 1. Feature Goal

**ID**: FEAT-004

Overhaul `vsCodeArenaAdapter.ts` so it is a thin relay to the VS Code extension host: every
Arena operation — session/message/document/settings CRUD, streaming chat, provider validation,
and model discovery — is delegated over `postMessage` using the protocol established by FEAT-003.
All in-memory state, direct `fetch()` LLM calls, the fake streaming simulation, and the
`getSystemPromptForAgent()` helper are removed. `vsCodeAdapter.ts`'s `handleMessage` switch is
extended to route the `arena.streamChunk` push event onto the `IAdapterEvents` event bus so
that the UI's `arenaStreamChunk` subscriptions continue to work.

---

## 2. Data Model (Granular)

### `responseDataMap` extension (inside `vsCodeArenaAdapter.ts`)

The adapter's internal `sendAndWait()` uses a `responseDataMap` to know which field of the
response message contains the result. The current map already has 7 arena entries. After this
feature it must contain all 17 request-response message types:

| Request `type` | Response data field | Notes |
|---|---|---|
| `arena.loadSessions` | `'sessions'` | already present |
| `arena.saveSession` | `''` | already present (void) |
| `arena.deleteSession` | `''` | already present (void) |
| `arena.loadMessages` | `'messages'` | already present |
| `arena.saveMessage` | `''` | already present (void) |
| `arena.clearSessionMessages` | `''` | **add** (void) |
| `arena.loadDocuments` | `'documents'` | already present |
| `arena.uploadDocument` | `'document'` | already present |
| `arena.deleteDocument` | `''` | **add** (void) |
| `arena.sendMessage` | _(remove)_ | no longer used |
| `arena.streamMessage` | `'response'` | already present |
| `arena.loadSettings` | `'settings'` | already present |
| `arena.saveSettings` | `''` | **add** (void) |
| `arena.loadReferences` | `'references'` | **add** |
| `arena.saveReferences` | `''` | **add** (void) |
| `arena.loadProviderSettings` | `'settings'` | **add** |
| `arena.saveProviderSettings` | `''` | **add** (void) |
| `arena.validateApiKey` | `'valid'` | already present |
| `arena.getAvailableModels` | `'models'` | **add** |

### `handleMessage` push-event routing (`vsCodeAdapter.ts`)

A single new `case` is added to the existing push-event `switch` in `vsCodeAdapter.ts`:

```typescript
case 'arena.streamChunk':
    events.emit('arenaStreamChunk', message.chunk);
    break;
```

`arena.streamComplete` and `arena.streamError` both carry a `requestId` so they are resolved
through the existing `pendingRequests` path — no additional cases needed.

### Removed state and functions

Everything listed below is **deleted** from `vsCodeArenaAdapter.ts`:

| Removed item | Replaced by |
|---|---|
| `localSessions: ArenaSession[]` | `sendAndWait('arena.loadSessions')` |
| `localMessages: Map<string, ArenaMessage[]>` | `sendAndWait('arena.loadMessages')` |
| `localDocuments: ArenaDocument[]` | `sendAndWait('arena.loadDocuments')` |
| `localSettings: ArenaSettings` | `sendAndWait('arena.loadSettings')` |
| `localReferences: ArenaReference[]` | `sendAndWait('arena.loadReferences')` |
| `localProviderSettings: ArenaProviderSettingsMap` | `sendAndWait('arena.loadProviderSettings')` |
| `vsCodeApi.getState()` restore block | — |
| `saveState()` function | — |
| `activeChatControllers` Map | fire-and-forget postMessage for cancelChat |
| `sendGeminiMessage()` | `sendAndWait('arena.streamMessage')` |
| `sendOllamaMessage()` | `sendAndWait('arena.streamMessage')` |
| `getSystemPromptForAgent()` (module-level function) | lives in ArenaService on extension host |

### Unused imports removed

After the overhaul, the following imports are no longer needed and must be removed:

```typescript
DEFAULT_ARENA_SETTINGS,
getDefaultProviderSettings,
geminiGenerateContentUrl,
ollamaChatUrl,
geminiModelsUrl,
ollamaTagsUrl,
ARENA_AGENT_IDS,
getModelsForProvider,
LLM_DEFAULTS,
```

---

## 3. Deviations from Plan

> Two interface mismatches between `IArenaAdapter` (in `@wave-client/core`) and the
> plan's message protocol require design adjustments. These do NOT require changing
> the `IArenaAdapter` interface (which is shared with `webArenaAdapter`).

**DEVIATION A — `validateApiKey`**:  
`IArenaAdapter.validateApiKey(provider: string, apiKey: string)` takes only the `apiKey`
string, not a full `ArenaProviderSettings` object. The adapter sends
`{ provider, apiKey }` in the postMessage. The FEAT-003 handler for `arena.validateApiKey`
already receives `providerSettings` — this needs a small adjustment: the `ArenaValidateApiKeyMsg`
interface should be `{ provider: string; apiKey: string }` and the handler constructs a minimal
`ArenaProviderSettings` from it (`{ provider, enabled: true, apiKey }`), then passes it to
`arenaService.validateApiKey`. Ollama validation ignores `apiKey` and uses the stored `baseUrl`
from `arenaStorageService` inside `ArenaService.validateApiKey`.

**DEVIATION B — `getAvailableModels`**:  
`IArenaAdapter.getAvailableModels?(provider: string)` takes only the provider string. The
adapter sends `{ provider }`. The FEAT-003 handler's `ArenaGetAvailableModelsMsg` should be
`{ provider: string }` only (not `providerSettings`). `ArenaService.getAvailableModels`
loads its own provider settings from `arenaStorageService`.

These two handlers in FEAT-003 need their message interfaces updated at implementation time
to match the actual IArenaAdapter signatures.

---

## 4. Files

- `packages/vscode/src/webview/adapters/vsCodeArenaAdapter.ts` — **Overhaul** — remove all
  in-memory state and direct fetch calls; every method delegates to the extension host
- `packages/vscode/src/webview/adapters/vsCodeAdapter.ts` — **Update** — add `arena.streamChunk`
  case to `handleMessage` push-event switch
- `packages/vscode/src/test/adapters/vsCodeArenaAdapter.test.ts` — **Create** — unit tests

---

## 5. Dependencies

- **FEAT-002** (`ArenaService`) must be complete before testing works end-to-end.
- **FEAT-003** (arena message handlers in `MessageHandler.ts`) must be complete before testing
  works end-to-end.
- The two adaptations noted in Deviations A and B require minor updates to the FEAT-003
  `ArenaValidateApiKeyMsg` and `ArenaGetAvailableModelsMsg` interfaces at implementation time.

---

## 6. Implementation Tasks

---

### TASK-001: Add `arena.streamChunk` push-event routing in `vsCodeAdapter.ts`

- [ ] **Implementation**:
  In `packages/vscode/src/webview/adapters/vsCodeAdapter.ts`, inside the `handleMessage`
  function's push-event `switch` block (the `case 'collectionsChanged':` etc. section),
  add:

  ```typescript
  // Arena streaming push events
  case 'arena.streamChunk':
      events.emit('arenaStreamChunk', message.chunk);
      break;
  ```

  Place this immediately before the default/end of the `switch` block, under a comment
  `// Arena streaming push events`.

  No other change to `vsCodeAdapter.ts` is needed. `arena.streamComplete` and
  `arena.streamError` carry `requestId` and are already handled by the
  `pendingRequests` path.

- [ ] **Unit Tests**: Covered in TASK-005.

- [ ] **Documentation Update**:
  Update the `handleMessage` JSDoc block in `vsCodeAdapter.ts` to note that
  `arena.streamChunk` is a push event with no `requestId`.

- **Verify**: `pnpm --filter @wave-client/vscode build` succeeds.

---

### TASK-002: Update `responseDataMap` and remove all in-memory state

- [ ] **Implementation**:
  In `packages/vscode/src/webview/adapters/vsCodeArenaAdapter.ts`:

  1. **Update `responseDataMap`** inside `sendAndWait()` to contain all 17 entries per the
     table in the Data Model section. Remove `'arena.sendMessage'` (no longer a valid message
     type). Add the new entries: `'arena.clearSessionMessages'`, `'arena.deleteDocument'`,
     `'arena.saveSettings'`, `'arena.loadReferences'`, `'arena.saveReferences'`,
     `'arena.loadProviderSettings'`, `'arena.saveProviderSettings'`, `'arena.getAvailableModels'`.

  2. **Delete** the entire in-memory state block (lines ~130-175 in the current file):
     ```typescript
     // DELETE: all lines from "For MVP, we'll store data locally..."
     // through the end of the vsCodeApi.getState() restore section
     let localSessions = ...
     let localMessages = ...
     let localDocuments = ...
     let localSettings = ...
     let localReferences = ...
     let localProviderSettings = ...
     const savedState = vsCodeApi.getState() as any;
     if (savedState?.arenaSessions) { ... }
     ...
     function saveState() { ... }
     ```

  3. **Delete** the `activeChatControllers` Map (no longer needed; cancellation is handled
     by the extension host's `AbortController` map from FEAT-003).

  4. **Remove unused imports** at the top of the file (listed in Data Model section):
     `DEFAULT_ARENA_SETTINGS`, `getDefaultProviderSettings`, `geminiGenerateContentUrl`,
     `ollamaChatUrl`, `geminiModelsUrl`, `ollamaTagsUrl`, `ARENA_AGENT_IDS`,
     `getModelsForProvider`, `LLM_DEFAULTS`.

- [ ] **Unit Tests**: Covered in TASK-005.

- [ ] **Documentation Update**:
  Update the file-level JSDoc (the "Note: For MVP..." block) to describe the new architecture:
  ```
  All Arena operations delegate to the VS Code extension host via postMessage.
  The extension host runs the real LangGraph agents, persists data to disk, and
  streams responses back as push events.
  ```

- **Verify**: `pnpm --filter @wave-client/vscode build` succeeds; TypeScript reports no
  unused import errors.

---

### TASK-003: Replace storage methods with `sendAndWait` delegation + event emissions

- [ ] **Implementation**:
  Replace **all 14 CRUD storage methods** in `vsCodeArenaAdapter.ts` with `sendAndWait`
  calls. The methods must also emit the appropriate `IAdapterEvents` events on success
  (matching the current behaviour so UI components continue to react to changes).

  The full replacement for each method follows this pattern:

  #### Session methods

  ```typescript
  async loadSessions(): Promise<Result<ArenaSession[], string>> {
      return sendAndWait<ArenaSession[]>('arena.loadSessions');
  },

  async saveSession(session: ArenaSession): Promise<Result<void, string>> {
      const result = await sendAndWait<void>('arena.saveSession', { session });
      if (result.isOk) {
          events.emit('arenaSessionsChanged', undefined);
      }
      return result;
  },

  async deleteSession(sessionId: string): Promise<Result<void, string>> {
      const result = await sendAndWait<void>('arena.deleteSession', { sessionId });
      if (result.isOk) {
          events.emit('arenaSessionsChanged', undefined);
      }
      return result;
  },
  ```

  #### Message methods

  ```typescript
  async loadMessages(sessionId: string): Promise<Result<ArenaMessage[], string>> {
      return sendAndWait<ArenaMessage[]>('arena.loadMessages', { sessionId });
  },

  async saveMessage(message: ArenaMessage): Promise<Result<void, string>> {
      const result = await sendAndWait<void>('arena.saveMessage', { message });
      if (result.isOk) {
          events.emit('arenaMessagesChanged', { sessionId: message.sessionId });
      }
      return result;
  },

  async clearSessionMessages(sessionId: string): Promise<Result<void, string>> {
      const result = await sendAndWait<void>('arena.clearSessionMessages', { sessionId });
      if (result.isOk) {
          events.emit('arenaMessagesChanged', { sessionId });
      }
      return result;
  },
  ```

  #### Document methods

  For `uploadDocument`, the adapter receives a browser `File` and an `ArrayBuffer`.
  It must construct the `ArenaDocument` metadata and encode the content to base64:

  ```typescript
  async uploadDocument(file: File, content: ArrayBuffer): Promise<Result<ArenaDocument, string>> {
      const metadata: ArenaDocument = {
          id: `doc-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`,
          filename: file.name,
          mimeType: file.type,
          size: file.size,
          uploadedAt: Date.now(),
          processed: false,
      };
      const contentBase64 = btoa(
          String.fromCharCode(...new Uint8Array(content))
      );
      const result = await sendAndWait<ArenaDocument>('arena.uploadDocument', {
          metadata,
          contentBase64,
      });
      if (result.isOk) {
          events.emit('arenaDocumentsChanged', undefined);
      }
      return result;
  },

  async loadDocuments(): Promise<Result<ArenaDocument[], string>> {
      return sendAndWait<ArenaDocument[]>('arena.loadDocuments');
  },

  async deleteDocument(documentId: string): Promise<Result<void, string>> {
      const result = await sendAndWait<void>('arena.deleteDocument', { documentId });
      if (result.isOk) {
          events.emit('arenaDocumentsChanged', undefined);
      }
      return result;
  },
  ```

  #### Settings, References, Provider Settings

  ```typescript
  async loadSettings(): Promise<Result<ArenaSettings, string>> {
      return sendAndWait<ArenaSettings>('arena.loadSettings');
  },

  async saveSettings(settings: ArenaSettings): Promise<Result<void, string>> {
      const result = await sendAndWait<void>('arena.saveSettings', { settings });
      if (result.isOk) {
          events.emit('arenaSettingsChanged', undefined);
      }
      return result;
  },

  async loadReferences(): Promise<Result<ArenaReference[], string>> {
      return sendAndWait<ArenaReference[]>('arena.loadReferences');
  },

  async saveReferences(references: ArenaReference[]): Promise<Result<void, string>> {
      return sendAndWait<void>('arena.saveReferences', { references });
  },

  async loadProviderSettings(): Promise<Result<ArenaProviderSettingsMap, string>> {
      return sendAndWait<ArenaProviderSettingsMap>('arena.loadProviderSettings');
  },

  async saveProviderSettings(settings: ArenaProviderSettingsMap): Promise<Result<void, string>> {
      return sendAndWait<void>('arena.saveProviderSettings', { settings });
  },
  ```

- [ ] **Unit Tests**: Covered in TASK-005.

- [ ] **Documentation Update**:
  Remove the `// For MVP, ...` comments from the storage methods; add brief JSDoc on
  `uploadDocument` explaining the base64 encoding step.

- **Verify**: `pnpm --filter @wave-client/vscode build` succeeds.

---

### TASK-004: Replace chat operations + remove `sendGeminiMessage`, `sendOllamaMessage`, `getSystemPromptForAgent`

- [ ] **Implementation**:

  #### Delete helper functions

  Delete the entire bodies of:
  - `sendGeminiMessage()` (and the function itself)
  - `sendOllamaMessage()` (and the function itself)
  - `getSystemPromptForAgent()` (module-level function at the bottom of the file)

  #### Replace `streamMessage`

  The new `streamMessage` subscribes to `arenaStreamChunk` events **before** sending the
  request, then unsubscribes using `events.off()` after the `sendAndWait` resolves.

  ```typescript
  async streamMessage(
      request: ArenaChatRequest,
      onChunk: (chunk: ArenaChatStreamChunk) => void
  ): Promise<Result<ArenaChatResponse, string>> {
      // Register the chunk handler BEFORE sending the stream request
      // so no chunks are missed during the async setup.
      const chunkHandler = (chunk: ArenaChatStreamChunk) => {
          onChunk(chunk);
          // Also re-emit on the event bus (existing ArenaPane subscriptions expect this)
          events.emit('arenaStreamChunk', chunk);
      };
      events.on('arenaStreamChunk', chunkHandler);

      try {
          return await sendAndWait<ArenaChatResponse>('arena.streamMessage', {
              chatRequest: request,
          });
      } finally {
          // Always unsubscribe, whether the request succeeded, failed, or was aborted
          events.off('arenaStreamChunk', chunkHandler);
      }
  },
  ```

  > **Note on double-emit**: `vsCodeAdapter.ts`'s `handleMessage` emits `arenaStreamChunk`
  > onto the event bus (TASK-001). The `chunkHandler` above also calls
  > `events.emit('arenaStreamChunk', chunk)`. This would cause each chunk to be emitted
  > **twice**. To prevent this, the `chunkHandler` should NOT call `events.emit` — the
  > event bus emission from `vsCodeAdapter.ts` TASK-001 is sufficient. The `chunkHandler`
  > only needs to call `onChunk(chunk)` for the direct callback (used by ArenaPane's
  > `streamMessage` call site).

  **Corrected implementation**:
  ```typescript
  async streamMessage(
      request: ArenaChatRequest,
      onChunk: (chunk: ArenaChatStreamChunk) => void
  ): Promise<Result<ArenaChatResponse, string>> {
      const chunkHandler = (chunk: ArenaChatStreamChunk) => {
          onChunk(chunk);
      };
      events.on('arenaStreamChunk', chunkHandler);
      try {
          return await sendAndWait<ArenaChatResponse>('arena.streamMessage', {
              chatRequest: request,
          });
      } finally {
          events.off('arenaStreamChunk', chunkHandler);
      }
  },
  ```

  #### Replace `sendMessage`

  The `IArenaAdapter.sendMessage()` method is used for non-streaming requests. After
  the migration, `streamMessage` IS the real implementation. `sendMessage` delegates to
  it with a no-op `onChunk`:

  ```typescript
  async sendMessage(request: ArenaChatRequest): Promise<Result<ArenaChatResponse, string>> {
      return this.streamMessage(request, () => { /* no-op: caller doesn't need chunk callbacks */ });
  },
  ```

  > **Implementation note**: `vsCodeArenaAdapter` is a plain object literal (not a class),
  > so `this.streamMessage` won't work. Call `streamMessage` directly as a local reference
  > or inline the `sendAndWait` call. The cleanest approach: extract `streamMessage` as
  > a local `async function` and then reference it in both `sendMessage` and `streamMessage`
  > adapter methods.

  #### Replace `cancelChat`

  `cancelChat` is synchronous and fire-and-forget. No `sendAndWait`, no response expected:

  ```typescript
  cancelChat(sessionId: string): void {
      vsCodeApi.postMessage({ type: 'arena.cancelChat', sessionId });
  },
  ```

  #### Replace `validateApiKey`

  Per Deviation A: adapter sends `{ provider, apiKey }`. The extension host constructs
  minimal providerSettings from these.

  ```typescript
  async validateApiKey(provider: string, apiKey: string): Promise<Result<boolean, string>> {
      return sendAndWait<boolean>('arena.validateApiKey', { provider, apiKey });
  },
  ```

  #### Replace `getAvailableModels`

  Per Deviation B: adapter sends only `{ provider }`.

  ```typescript
  async getAvailableModels?(provider: string): Promise<Result<{ id: string; label: string }[], string>> {
      return sendAndWait<{ id: string; label: string }[]>('arena.getAvailableModels', { provider });
  },
  ```

- [ ] **Unit Tests**: Covered in TASK-005.

- [ ] **Documentation Update**:
  Add JSDoc to `streamMessage` explaining the subscribe-before-send pattern and why
  `events.off()` is in a `finally` block. Add a comment to `cancelChat` noting it is
  fire-and-forget (no response). Add a comment to `sendMessage` noting it delegates
  to `streamMessage`.

- **Verify**: `pnpm --filter @wave-client/vscode build` succeeds with zero TypeScript errors.

---

### TASK-005: Unit tests for the overhauled adapter and stream routing

- [ ] **Implementation**:
  Create `packages/vscode/src/test/adapters/vsCodeArenaAdapter.test.ts`.

  Follow the existing `MessageHandler.test.ts` and `SecurityService.test.ts` Vitest patterns.
  Mock `vscode` and all services. Mock `vsCodeApi` as an object with a `postMessage` spy.

  #### Test setup

  ```typescript
  import { describe, it, expect, vi, beforeEach } from 'vitest';
  import { createAdapterEventEmitter } from '@wave-client/core';

  vi.mock('vscode', () => ({ window: {}, workspace: { getConfiguration: vi.fn(() => ({ get: vi.fn() })) } }));

  let mockVsCodeApi: { postMessage: ReturnType<typeof vi.fn>; getState: ReturnType<typeof vi.fn>; setState: ReturnType<typeof vi.fn> };
  let pendingRequests: Map<string, any>;
  let events: any;
  let adapter: any;

  beforeEach(async () => {
      vi.clearAllMocks();
      mockVsCodeApi = {
          postMessage: vi.fn(),
          getState: vi.fn(() => ({})),
          setState: vi.fn(),
      };
      pendingRequests = new Map();
      events = createAdapterEventEmitter();

      const { createVSCodeArenaAdapter } = await import('../../webview/adapters/vsCodeArenaAdapter.js');
      adapter = createVSCodeArenaAdapter(mockVsCodeApi, pendingRequests, events, 5000);
  });

  /** Simulate the extension host resolving a pending request */
  function resolveRequest(requestId: string, responseData: Record<string, unknown>) {
      const pending = pendingRequests.get(requestId);
      if (pending) {
          clearTimeout(pending.timeout);
          pendingRequests.delete(requestId);
          pending.resolve(responseData);
      }
  }

  /** Get the requestId from the most recent postMessage call */
  function lastRequestId(): string {
      const lastCall = mockVsCodeApi.postMessage.mock.calls.at(-1)?.[0];
      return lastCall?.requestId;
  }
  ```

  #### Test cases

  **Storage — sessions**:
  - `loadSessions()` sends `{ type: 'arena.loadSessions' }` to the extension; when resolved
    with `{ sessions: [session1] }`, returns `ok([session1])`
  - `saveSession(session)` sends correct postMessage; on success, emits `arenaSessionsChanged`
    event; returns `ok(undefined)`
  - `saveSession(session)` — when extension responds with `{ error: 'disk full' }`, returns
    `err('disk full')` and does NOT emit `arenaSessionsChanged`
  - `deleteSession(sessionId)` sends `{ type: 'arena.deleteSession', sessionId }` and emits
    `arenaSessionsChanged` on success

  **Storage — messages**:
  - `loadMessages(sessionId)` sends `{ type: 'arena.loadMessages', sessionId }` and returns
    the `messages` array
  - `saveMessage(message)` sends correct postMessage; on success, emits `arenaMessagesChanged`
    with `{ sessionId: message.sessionId }`
  - `clearSessionMessages(sessionId)` sends correct postMessage and emits `arenaMessagesChanged`

  **Storage — documents**:
  - `uploadDocument(file, content)` sends `{ type: 'arena.uploadDocument', metadata, contentBase64 }`;
    `contentBase64` is the base64-encoded `ArrayBuffer`; on success, emits `arenaDocumentsChanged`
  - `deleteDocument(documentId)` sends correct postMessage and emits `arenaDocumentsChanged`

  **Storage — settings & references**:
  - `loadSettings()` returns the `settings` from the response
  - `saveSettings(settings)` sends correct postMessage; emits `arenaSettingsChanged` on success
  - `loadReferences()` sends `{ type: 'arena.loadReferences' }` and returns `references`
  - `saveReferences(refs)` sends `{ type: 'arena.saveReferences', references: refs }`
  - `loadProviderSettings()` returns `settings` (the ArenaProviderSettingsMap field)
  - `saveProviderSettings(settings)` sends `{ type: 'arena.saveProviderSettings', settings }`

  **Chat — streamMessage**:
  - `streamMessage(request, onChunk)`:
    1. Subscribes to `arenaStreamChunk` BEFORE the `postMessage` call (verify by emitting
       a chunk immediately after `streamMessage` is called but before resolving the pending
       request — `onChunk` must be called)
    2. When `arenaStreamChunk` is emitted on the event bus, `onChunk` is called with the chunk
    3. After `arena.streamComplete` resolves the pending promise, `onChunk` is no longer called
       (i.e., events emitted after completion are ignored)
    4. Returns `ok(response)` when the pending request resolves with `{ response }`
    5. Returns `err(message)` when the pending request resolves with `{ error: message }`

  **Chat — sendMessage**:
  - `sendMessage(request)` sends `{ type: 'arena.streamMessage' }` (delegates to streamMessage)

  **Chat — cancelChat**:
  - `cancelChat(sessionId)` calls `vsCodeApi.postMessage({ type: 'arena.cancelChat', sessionId })`
    synchronously (no `requestId`)

  **validateApiKey**:
  - `validateApiKey('gemini', 'key123')` sends `{ type: 'arena.validateApiKey', provider: 'gemini', apiKey: 'key123' }`
  - Response with `{ valid: true }` → returns `ok(true)`
  - Response with `{ valid: false }` → returns `ok(false)` (not an error; the adapter returns whatever the extension host says)

  **getAvailableModels**:
  - `getAvailableModels('ollama')` sends `{ type: 'arena.getAvailableModels', provider: 'ollama' }`
  - Response with `{ models: [{ id: 'llama3', label: 'llama3' }] }` → returns `ok([...])`

  **Timeout**:
  - If the extension host does not respond within the timeout, returns `err('Request timed out: arena.loadSessions')`

  **`arena.streamChunk` routing in `vsCodeAdapter.ts`** (separate describe block):
  - `handleMessage` called with `{ type: 'arena.streamChunk', chunk: { messageId: 'm1', content: 'hi', done: false } }` → emits `arenaStreamChunk` on the event bus with the chunk payload

- [ ] **Documentation Update**: N/A — test file is self-documenting.

- **Verify**: `pnpm --filter @wave-client/vscode test` passes with all new test cases green.

---

## 7. Cross-Cutting Concerns

### No Local State — Adapter is Stateless

After the overhaul, `vsCodeArenaAdapter.ts` holds zero in-memory domain state. It is a pure
relay. All state lives on disk in the extension host. This aligns with the core architecture
rule: all I/O belongs in the extension host (or server), never in the webview process.

### Event Emissions Preserved

The existing React components subscribe to `arenaSessionsChanged`, `arenaMessagesChanged`,
`arenaDocumentsChanged`, and `arenaSettingsChanged` via `useAdapterEvents` hooks. All mutation
methods (save\*, delete\*) continue to emit these events on success so no UI logic needs to
change in this feature.

### Streaming: Subscribe-Before-Send Pattern

`streamMessage` registers `chunkHandler` via `events.on()` BEFORE calling
`sendAndWait('arena.streamMessage')`. This prevents a race condition where the extension host
could send the first `arena.streamChunk` push event before the adapter has subscribed. The
`finally` block in `streamMessage` guarantees `events.off()` is called regardless of whether
the stream completed normally, errored, or was aborted.

### Double-Emit Avoided

Both `vsCodeAdapter.ts` (TASK-001) and `streamMessage` receive the `arena.streamChunk` push
event. If `streamMessage`'s `chunkHandler` were to call `events.emit('arenaStreamChunk', chunk)`,
every chunk would fire twice (once from `vsCodeAdapter.ts` and once from `chunkHandler`).
`chunkHandler` calls ONLY `onChunk(chunk)` — never `events.emit`. The single canonical
emission comes from `vsCodeAdapter.ts`.

### Security

Provider settings and API keys are transmitted in `arena.saveProviderSettings` payloads. The
adapter must not log `postMessage` payloads that contain provider settings. No logging is added
to `vsCodeArenaAdapter.ts` in this feature (consistent with existing adapter pattern).

### `IArenaAdapter` Compatibility

`IArenaAdapter` is not modified in this feature. The adapter continues to satisfy the full
interface. No other implementations (`webArenaAdapter`) are impacted.

---

## 8. State Tracking

```
[FEAT-004]  Updated vsCodeArenaAdapter
  [TASK-001] Add arena.streamChunk routing to vsCodeAdapter.ts handleMessage  [ ] not-started
  [TASK-002] Update responseDataMap + remove all in-memory state               [ ] not-started
  [TASK-003] Replace all 14 storage methods with sendAndWait delegation        [ ] not-started
  [TASK-004] Replace chat ops + delete sendGemini/sendOllama/getSystemPrompt   [ ] not-started
  [TASK-005] Unit tests for adapter and streamChunk routing                    [ ] not-started
```
