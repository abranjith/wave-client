<!-- Generated by spec-lite v0.0.4 | sub-agent: feature | date: 2026-02-21 -->

# Feature: Arena Message Handlers

## 1. Feature Goal

**ID**: FEAT-003

Add all Arena-related `postMessage` routing to `MessageHandler.ts` so the VS Code extension
host can respond to every Arena request from the webview. This covers 18 message types:
16 storage CRUD operations (sessions, messages, documents, references, settings, provider
settings), 2 action operations (provider validation and model discovery), and the streaming
chat protocol with per-chunk push events and `AbortController`-based cancellation.

After this feature, the webview can drive all Arena functionality purely via `postMessage` —
no direct `fetch` calls, no in-memory state in the adapter.

---

## 2. Data Model (Granular)

### postMessage Payload Shapes

All inbound messages follow the existing `{ type: string, requestId: string, ...data }` shape
established in the rest of `MessageHandler`. Outbound responses use the same `requestId` for
correlation. The `arena.streamChunk` push event is the sole exception — it carries no
`requestId` (it is a push event keyed only on `sessionId`).

All payload interfaces are defined in `packages/vscode/src/services/types.ts` and imported by
`MessageHandler.ts`.

#### Inbound message interfaces

```typescript
// Storage — sessions
interface ArenaLoadSessionsMsg   { type: 'arena.loadSessions';   requestId: string }
interface ArenaSaveSessionMsg    { type: 'arena.saveSession';    requestId: string; session: ArenaSession }
interface ArenaDeleteSessionMsg  { type: 'arena.deleteSession';  requestId: string; sessionId: string }

// Storage — messages
interface ArenaLoadMessagesMsg    { type: 'arena.loadMessages';      requestId: string; sessionId: string }
interface ArenaSaveMessageMsg     { type: 'arena.saveMessage';       requestId: string; message: ArenaMessage }
interface ArenaClearMessagesMsg   { type: 'arena.clearSessionMessages'; requestId: string; sessionId: string }

// Storage — documents
interface ArenaLoadDocumentsMsg   { type: 'arena.loadDocuments';   requestId: string }
interface ArenaUploadDocumentMsg  { type: 'arena.uploadDocument';  requestId: string; metadata: ArenaDocument; contentBase64: string }
interface ArenaDeleteDocumentMsg  { type: 'arena.deleteDocument';  requestId: string; documentId: string }

// Storage — settings & references
interface ArenaLoadSettingsMsg         { type: 'arena.loadSettings';         requestId: string }
interface ArenaSaveSettingsMsg         { type: 'arena.saveSettings';         requestId: string; settings: ArenaSettings }
interface ArenaLoadReferencesMsg       { type: 'arena.loadReferences';       requestId: string }
interface ArenaSaveReferencesMsg       { type: 'arena.saveReferences';       requestId: string; references: ArenaReference[] }
interface ArenaLoadProviderSettingsMsg { type: 'arena.loadProviderSettings'; requestId: string }
interface ArenaSaveProviderSettingsMsg { type: 'arena.saveProviderSettings'; requestId: string; settings: ArenaProviderSettingsMap }

// Actions
interface ArenaValidateApiKeyMsg    { type: 'arena.validateApiKey';    requestId: string; provider: ArenaProviderType; providerSettings: ArenaProviderSettings }
interface ArenaGetAvailableModelsMsg { type: 'arena.getAvailableModels'; requestId: string; provider: ArenaProviderType; providerSettings: ArenaProviderSettings }

// Streaming
interface ArenaStreamMessageMsg { type: 'arena.streamMessage'; requestId: string; chatRequest: ArenaChatRequest }
interface ArenaCancelChatMsg    { type: 'arena.cancelChat';    sessionId: string }  // no requestId — fire-and-forget
```

#### Outbound response shapes

All successful storage responses echo the `requestId` and carry a single named data field
(or no data for void operations). All error responses echo `requestId` and carry `error: string`.

| Response `type` | Data field(s) |
|---|---|
| `arena.loadSessions` | `sessions: ArenaSession[]` |
| `arena.saveSession` | — |
| `arena.deleteSession` | — |
| `arena.loadMessages` | `messages: ArenaMessage[]` |
| `arena.saveMessage` | — |
| `arena.clearSessionMessages` | — |
| `arena.loadDocuments` | `documents: ArenaDocument[]` |
| `arena.uploadDocument` | `document: ArenaDocument` |
| `arena.deleteDocument` | — |
| `arena.loadSettings` | `settings: ArenaSettings` |
| `arena.saveSettings` | — |
| `arena.loadReferences` | `references: ArenaReference[]` |
| `arena.saveReferences` | — |
| `arena.loadProviderSettings` | `settings: ArenaProviderSettingsMap` |
| `arena.saveProviderSettings` | — |
| `arena.validateApiKey` | `valid: boolean, error?: string` |
| `arena.getAvailableModels` | `models: ModelDefinition[]` |
| `arena.streamChunk` | `sessionId: string, chunk: ArenaChatStreamChunk` (push, no requestId) |
| `arena.streamComplete` | `requestId: string, response: ArenaChatResponse` |
| `arena.streamError` | `requestId: string, error: string` |

### `saveMessage` upsert semantics

`arena.saveMessage` receives a single `ArenaMessage`. The handler:
1. Loads the current `messages` array for `message.sessionId` from disk.
2. Upserts by `message.id` (replace if found, push if not).
3. Writes the updated array back to disk.

This is the only handler that performs a read-modify-write within a single request.

### `uploadDocument` content handling

Base64 is used across the `postMessage` boundary (no `Buffer` in the webview).
The handler decodes `contentBase64` to a `Buffer` using `Buffer.from(contentBase64, 'base64')`
and passes it to `arenaStorageService.saveDocumentContent()`.

### `AbortController` lifecycle

`MessageHandler` holds a new private field:
```typescript
private arenaAbortControllers = new Map<string, AbortController>();
```
- On `arena.streamMessage`: create a new `AbortController` keyed to `chatRequest.sessionId`,
  store it, call `arenaService.streamChat(...)`, then delete the entry on completion or error.
- On `arena.cancelChat`: call `.abort()` on the matching controller (if present); no response.

---

## 3. Files

- `packages/vscode/src/services/types.ts` — **Update** — add all 19 arena message payload interfaces
- `packages/vscode/src/handlers/MessageHandler.ts` — **Update** — import arena services + add arena switch cases and handler methods
- `packages/vscode/src/test/handlers/MessageHandler.test.ts` — **Update** — add arena message handler test cases

---

## 4. Dependencies

- **FEAT-001** (`ArenaStorageService` + `arenaStorageService` in `@wave-client/shared`) must be
  complete; the handlers call methods on `arenaStorageService`.
- **FEAT-002** (`ArenaService` + `arenaService` in `packages/vscode/src/services/`) must be
  complete; the stream and action handlers call `arenaService.streamChat()`,
  `arenaService.validateApiKey()`, and `arenaService.getAvailableModels()`.

No new packages are required; the arena services are exported from `packages/vscode/src/services/index.ts` after FEAT-002.

---

## 5. Implementation Tasks

---

### TASK-001: Typed arena message payload interfaces in `services/types.ts`

- [ ] **Implementation**:
  Add the full set of inbound arena message payload interfaces to
  `packages/vscode/src/services/types.ts`.

  Import the required core types at the top of the file:
  ```typescript
  import type {
    ArenaSession,
    ArenaMessage,
    ArenaDocument,
    ArenaReference,
    ArenaSettings,
    ArenaProviderSettingsMap,
    ArenaProviderSettings,
    ArenaProviderType,
    ArenaChatRequest,
  } from '@wave-client/core';
  ```

  Then define and export all 19 interfaces listed in the Data Model section above
  (`ArenaLoadSessionsMsg`, `ArenaSaveSessionMsg`, …, `ArenaCancelChatMsg`).

  Finally, add a discriminated union type for convenient narrowing in `MessageHandler`:
  ```typescript
  export type ArenaMessage =
    | ArenaLoadSessionsMsg
    | ArenaSaveSessionMsg
    | ArenaDeleteSessionMsg
    | ArenaLoadMessagesMsg
    | ArenaSaveMessageMsg
    | ArenaClearMessagesMsg
    | ArenaLoadDocumentsMsg
    | ArenaUploadDocumentMsg
    | ArenaDeleteDocumentMsg
    | ArenaLoadSettingsMsg
    | ArenaSaveSettingsMsg
    | ArenaLoadReferencesMsg
    | ArenaSaveReferencesMsg
    | ArenaLoadProviderSettingsMsg
    | ArenaSaveProviderSettingsMsg
    | ArenaValidateApiKeyMsg
    | ArenaGetAvailableModelsMsg
    | ArenaStreamMessageMsg
    | ArenaCancelChatMsg;
  ```

  > **Naming note**: `ArenaMessage` (from `@wave-client/core`) refers to a chat message entity.
  > The union type above represents *postMessage protocol messages* and must be named differently
  > to avoid a collision. Name it `ArenaPostMessage` instead.

- [ ] **Unit Tests**: N/A — type-only file; verified by TypeScript compilation.

- [ ] **Documentation Update**:
  Add a section comment above the arena block:
  ```typescript
  // ============================================================
  // Arena postMessage payload types
  // ============================================================
  ```

- **Verify**: `pnpm --filter @wave-client/vscode build` succeeds with no TypeScript errors.

---

### TASK-002: Arena storage CRUD handlers (sessions, messages, documents)

- [ ] **Implementation**:
  In `packages/vscode/src/handlers/MessageHandler.ts`:

  1. **Import** `arenaStorageService` from `'../services'` alongside the existing service imports.
  2. **Add switch cases** for the 9 storage message types in `handleMessage()`, grouped under a
     `// Arena storage handlers` comment:
     ```typescript
     case 'arena.loadSessions':
     case 'arena.saveSession':
     case 'arena.deleteSession':
     case 'arena.loadMessages':
     case 'arena.saveMessage':
     case 'arena.clearSessionMessages':
     case 'arena.loadDocuments':
     case 'arena.uploadDocument':
     case 'arena.deleteDocument':
     ```
  3. **Add private handler methods** following the exact same structure as existing handlers:

  ```typescript
  // ==================== Arena Storage Handlers — Sessions ====================

  private async handleArenaLoadSessions(message: ArenaLoadSessionsMsg): Promise<void> {
    const { requestId } = message;
    try {
      const sessions = await arenaStorageService.loadSessions();
      this.postMessage({ type: 'arena.loadSessions', requestId, sessions });
    } catch (error: any) {
      this.postMessage({ type: 'arena.loadSessions', requestId, error: error.message });
    }
  }

  private async handleArenaSaveSession(message: ArenaSaveSessionMsg): Promise<void> {
    const { requestId, session } = message;
    try {
      await arenaStorageService.saveSession(session);
      this.postMessage({ type: 'arena.saveSession', requestId });
    } catch (error: any) {
      this.postMessage({ type: 'arena.saveSession', requestId, error: error.message });
    }
  }

  private async handleArenaDeleteSession(message: ArenaDeleteSessionMsg): Promise<void> {
    const { requestId, sessionId } = message;
    try {
      await arenaStorageService.deleteSession(sessionId);
      this.postMessage({ type: 'arena.deleteSession', requestId });
    } catch (error: any) {
      this.postMessage({ type: 'arena.deleteSession', requestId, error: error.message });
    }
  }

  // ==================== Arena Storage Handlers — Messages ====================

  private async handleArenaLoadMessages(message: ArenaLoadMessagesMsg): Promise<void> {
    const { requestId, sessionId } = message;
    try {
      const messages = await arenaStorageService.loadMessages(sessionId);
      this.postMessage({ type: 'arena.loadMessages', requestId, messages });
    } catch (error: any) {
      this.postMessage({ type: 'arena.loadMessages', requestId, error: error.message });
    }
  }

  private async handleArenaSaveMessage(message: ArenaSaveMessageMsg): Promise<void> {
    const { requestId } = message;
    try {
      // Upsert: load current array, replace/push, write back
      const existing = await arenaStorageService.loadMessages(message.message.sessionId);
      const idx = existing.findIndex((m) => m.id === message.message.id);
      if (idx >= 0) {
        existing[idx] = message.message;
      } else {
        existing.push(message.message);
      }
      await arenaStorageService.saveMessages(message.message.sessionId, existing);
      this.postMessage({ type: 'arena.saveMessage', requestId });
    } catch (error: any) {
      this.postMessage({ type: 'arena.saveMessage', requestId, error: error.message });
    }
  }

  private async handleArenaClearSessionMessages(message: ArenaClearMessagesMsg): Promise<void> {
    const { requestId, sessionId } = message;
    try {
      await arenaStorageService.clearSessionMessages(sessionId);
      this.postMessage({ type: 'arena.clearSessionMessages', requestId });
    } catch (error: any) {
      this.postMessage({ type: 'arena.clearSessionMessages', requestId, error: error.message });
    }
  }

  // ==================== Arena Storage Handlers — Documents ====================

  private async handleArenaLoadDocuments(message: ArenaLoadDocumentsMsg): Promise<void> {
    const { requestId } = message;
    try {
      const documents = await arenaStorageService.loadDocuments();
      this.postMessage({ type: 'arena.loadDocuments', requestId, documents });
    } catch (error: any) {
      this.postMessage({ type: 'arena.loadDocuments', requestId, error: error.message });
    }
  }

  private async handleArenaUploadDocument(message: ArenaUploadDocumentMsg): Promise<void> {
    const { requestId, metadata, contentBase64 } = message;
    try {
      const content = Buffer.from(contentBase64, 'base64');
      await arenaStorageService.saveDocumentContent(metadata.id, content);
      await arenaStorageService.saveDocumentMetadata(metadata);
      this.postMessage({ type: 'arena.uploadDocument', requestId, document: metadata });
    } catch (error: any) {
      this.postMessage({ type: 'arena.uploadDocument', requestId, error: error.message });
    }
  }

  private async handleArenaDeleteDocument(message: ArenaDeleteDocumentMsg): Promise<void> {
    const { requestId, documentId } = message;
    try {
      await arenaStorageService.deleteDocument(documentId);
      this.postMessage({ type: 'arena.deleteDocument', requestId });
    } catch (error: any) {
      this.postMessage({ type: 'arena.deleteDocument', requestId, error: error.message });
    }
  }
  ```

- [ ] **Unit Tests**: Covered in TASK-005.

- [ ] **Documentation Update**:
  Add section header comments above the three sub-groups (Sessions, Messages, Documents)
  as shown in the code above.

- **Verify**: `pnpm --filter @wave-client/vscode build` succeeds.

---

### TASK-003: Arena storage CRUD handlers (settings, references, provider settings)

- [ ] **Implementation**:
  In `MessageHandler.ts`, add switch cases and handler methods for the remaining 6 storage types:
  ```typescript
  case 'arena.loadSettings':
  case 'arena.saveSettings':
  case 'arena.loadReferences':
  case 'arena.saveReferences':
  case 'arena.loadProviderSettings':
  case 'arena.saveProviderSettings':
  ```

  All follow the identical try/catch + `postMessage` pattern from TASK-002:

  ```typescript
  // ==================== Arena Storage Handlers — Settings & References ====================

  private async handleArenaLoadSettings(message: ArenaLoadSettingsMsg): Promise<void> {
    const { requestId } = message;
    try {
      const settings = await arenaStorageService.loadSettings();
      this.postMessage({ type: 'arena.loadSettings', requestId, settings });
    } catch (error: any) {
      this.postMessage({ type: 'arena.loadSettings', requestId, error: error.message });
    }
  }

  private async handleArenaSaveSettings(message: ArenaSaveSettingsMsg): Promise<void> {
    const { requestId, settings } = message;
    try {
      await arenaStorageService.saveSettings(settings);
      this.postMessage({ type: 'arena.saveSettings', requestId });
    } catch (error: any) {
      this.postMessage({ type: 'arena.saveSettings', requestId, error: error.message });
    }
  }

  private async handleArenaLoadReferences(message: ArenaLoadReferencesMsg): Promise<void> {
    const { requestId } = message;
    try {
      const references = await arenaStorageService.loadReferences();
      this.postMessage({ type: 'arena.loadReferences', requestId, references });
    } catch (error: any) {
      this.postMessage({ type: 'arena.loadReferences', requestId, error: error.message });
    }
  }

  private async handleArenaSaveReferences(message: ArenaSaveReferencesMsg): Promise<void> {
    const { requestId, references } = message;
    try {
      await arenaStorageService.saveReferences(references);
      this.postMessage({ type: 'arena.saveReferences', requestId });
    } catch (error: any) {
      this.postMessage({ type: 'arena.saveReferences', requestId, error: error.message });
    }
  }

  private async handleArenaLoadProviderSettings(message: ArenaLoadProviderSettingsMsg): Promise<void> {
    const { requestId } = message;
    try {
      const settings = await arenaStorageService.loadProviderSettings();
      this.postMessage({ type: 'arena.loadProviderSettings', requestId, settings });
    } catch (error: any) {
      this.postMessage({ type: 'arena.loadProviderSettings', requestId, error: error.message });
    }
  }

  private async handleArenaSaveProviderSettings(message: ArenaSaveProviderSettingsMsg): Promise<void> {
    const { requestId, settings } = message;
    try {
      await arenaStorageService.saveProviderSettings(settings);
      this.postMessage({ type: 'arena.saveProviderSettings', requestId });
    } catch (error: any) {
      this.postMessage({ type: 'arena.saveProviderSettings', requestId, error: error.message });
    }
  }
  ```

- [ ] **Unit Tests**: Covered in TASK-005.

- [ ] **Documentation Update**:
  Section comment `// ==================== Arena Storage Handlers — Settings & References ====================`.

- **Verify**: `pnpm --filter @wave-client/vscode build` succeeds.

---

### TASK-004: Arena action handlers — validateApiKey, getAvailableModels, streamMessage, cancelChat

- [ ] **Implementation**:
  In `MessageHandler.ts`:

  1. **Import** `arenaService` from `'../services'`.
  2. **Add private field** for the AbortController map immediately after the class opening:
     ```typescript
     private arenaAbortControllers = new Map<string, AbortController>();
     ```
  3. **Add switch cases** grouped under `// Arena action handlers`:
     ```typescript
     case 'arena.validateApiKey':
     case 'arena.getAvailableModels':
     case 'arena.streamMessage':
     case 'arena.cancelChat':
     ```
  4. **Add private handler methods**:

  ```typescript
  // ==================== Arena Action Handlers ====================

  private async handleArenaValidateApiKey(message: ArenaValidateApiKeyMsg): Promise<void> {
    const { requestId, provider, providerSettings } = message;
    try {
      const result = await arenaService.validateApiKey(provider, providerSettings);
      this.postMessage({ type: 'arena.validateApiKey', requestId, valid: result.valid, error: result.error });
    } catch (error: any) {
      this.postMessage({ type: 'arena.validateApiKey', requestId, valid: false, error: error.message });
    }
  }

  private async handleArenaGetAvailableModels(message: ArenaGetAvailableModelsMsg): Promise<void> {
    const { requestId, provider, providerSettings } = message;
    try {
      const models = await arenaService.getAvailableModels(provider, providerSettings);
      this.postMessage({ type: 'arena.getAvailableModels', requestId, models });
    } catch (error: any) {
      this.postMessage({ type: 'arena.getAvailableModels', requestId, models: [], error: error.message });
    }
  }

  private async handleArenaStreamMessage(message: ArenaStreamMessageMsg): Promise<void> {
    const { requestId, chatRequest } = message;
    const { sessionId } = chatRequest;

    // Create an AbortController for this session so cancelChat can abort it
    const controller = new AbortController();
    this.arenaAbortControllers.set(sessionId, controller);

    try {
      const response = await arenaService.streamChat(
        chatRequest,
        (chunk) => {
          // Push each token to the webview — no requestId on stream chunks
          this.postMessage({ type: 'arena.streamChunk', sessionId, chunk });
        },
        controller.signal,
      );
      this.postMessage({ type: 'arena.streamComplete', requestId, response });
    } catch (error: any) {
      this.postMessage({ type: 'arena.streamError', requestId, error: error.message });
    } finally {
      this.arenaAbortControllers.delete(sessionId);
    }
  }

  private handleArenaCancelChat(message: ArenaCancelChatMsg): void {
    const controller = this.arenaAbortControllers.get(message.sessionId);
    if (controller) {
      controller.abort();
    }
    // Fire-and-forget: no response
  }
  ```

  Note: `handleArenaCancelChat` is synchronous (no `async` keyword) because `AbortController.abort()`
  is synchronous.

  **Wire the switch cases**:
  ```typescript
  case 'arena.cancelChat':
    this.handleArenaCancelChat(message as ArenaCancelChatMsg);
    break;
  case 'arena.validateApiKey':
    await this.handleArenaValidateApiKey(message as ArenaValidateApiKeyMsg);
    break;
  case 'arena.getAvailableModels':
    await this.handleArenaGetAvailableModels(message as ArenaGetAvailableModelsMsg);
    break;
  case 'arena.streamMessage':
    await this.handleArenaStreamMessage(message as ArenaStreamMessageMsg);
    break;
  ```

- [ ] **Unit Tests**: Covered in TASK-005.

- [ ] **Documentation Update**:
  Add JSDoc to `handleArenaStreamMessage` explaining the AbortController lifecycle and the
  push-event vs requestId distinction:
  ```typescript
  /**
   * Handles a streaming chat request.
   *
   * Stream chunks are pushed to the webview as `arena.streamChunk` events (no requestId).
   * The final `arena.streamComplete` / `arena.streamError` carries the original requestId
   * to resolve the webview's pending `sendAndWait` promise.
   *
   * An `AbortController` is registered for the session to support cancellation via
   * `arena.cancelChat`.
   */
  ```

- **Verify**: `pnpm --filter @wave-client/vscode build` succeeds.

---

### TASK-005: Unit tests for all new arena message handlers

- [ ] **Implementation**:
  Update `packages/vscode/src/test/handlers/MessageHandler.test.ts`.

  #### Add arena mocks to the existing `vi.mock('../../services', ...)` call

  Extend the mock object returned by `'../../services'` with:
  ```typescript
  arenaStorageService: {
    loadSessions: vi.fn(),
    saveSession: vi.fn(),
    deleteSession: vi.fn(),
    loadMessages: vi.fn(),
    saveMessages: vi.fn(),
    clearSessionMessages: vi.fn(),
    loadDocuments: vi.fn(),
    saveDocumentMetadata: vi.fn(),
    saveDocumentContent: vi.fn(),
    deleteDocument: vi.fn(),
    loadSettings: vi.fn(),
    saveSettings: vi.fn(),
    loadReferences: vi.fn(),
    saveReferences: vi.fn(),
    loadProviderSettings: vi.fn(),
    saveProviderSettings: vi.fn(),
  },
  arenaService: {
    validateApiKey: vi.fn(),
    getAvailableModels: vi.fn(),
    streamChat: vi.fn(),
  },
  ```

  #### Test cases to add

  Group them in a `describe('Arena handlers', () => { ... })` block:

  **Storage — sessions**:
  - `arena.loadSessions` → `arenaStorageService.loadSessions()` called; response has `type: 'arena.loadSessions'` and `sessions` array
  - `arena.loadSessions` service throws → response has `error` field
  - `arena.saveSession` → `arenaStorageService.saveSession()` called with the session object; response has `type: 'arena.saveSession'` (no data)
  - `arena.deleteSession` → `arenaStorageService.deleteSession()` called with the correct `sessionId`

  **Storage — messages**:
  - `arena.loadMessages` → `arenaStorageService.loadMessages(sessionId)` called; response has `messages` array
  - `arena.saveMessage` (new message, not in existing list) → `loadMessages` then `saveMessages` called; `saveMessages` receives array with new message appended
  - `arena.saveMessage` (existing message) → `saveMessages` receives array where original is replaced
  - `arena.clearSessionMessages` → `arenaStorageService.clearSessionMessages()` called

  **Storage — documents**:
  - `arena.uploadDocument` → `saveDocumentContent` called with `Buffer.from(contentBase64, 'base64')`; `saveDocumentMetadata` called with the metadata object; response has `document` field
  - `arena.deleteDocument` → `arenaStorageService.deleteDocument(documentId)` called

  **Storage — settings & references**:
  - `arena.loadSettings` → response has `settings` field
  - `arena.saveSettings` → `arenaStorageService.saveSettings()` called with correct settings object
  - `arena.loadReferences` → response has `references` array
  - `arena.saveReferences` → `arenaStorageService.saveReferences()` called
  - `arena.loadProviderSettings` → response has `settings` field (ArenaProviderSettingsMap)
  - `arena.saveProviderSettings` → `arenaStorageService.saveProviderSettings()` called

  **Actions — validateApiKey**:
  - `arenaService.validateApiKey` returns `{ valid: true }` → response `valid: true`
  - `arenaService.validateApiKey` returns `{ valid: false, error: 'bad key' }` → response `valid: false, error: 'bad key'`

  **Actions — getAvailableModels**:
  - `arenaService.getAvailableModels` returns model list → response has `models` array

  **Streaming — streamMessage**:
  - `arenaService.streamChat` resolves with a response → `arena.streamComplete` is posted with `requestId` and `response`
  - `arenaService.streamChat` rejects with an error → `arena.streamError` is posted with `requestId` and `error`
  - During streaming, the `onChunk` callback passed to `streamChat` — when called — posts `arena.streamChunk` with `sessionId` and `chunk` (no `requestId`)
  - After completion, the `AbortController` entry is removed from the map (verify by calling `arena.cancelChat` for the same sessionId after streaming completes and asserting the abort is a no-op)

  **Streaming — cancelChat**:
  - While a stream is in progress, `arena.cancelChat` with the matching `sessionId` calls `abort()` on the controller (use `vi.spyOn(AbortController.prototype, 'abort')`)
  - `arena.cancelChat` with an unknown `sessionId` does NOT throw

- [ ] **Documentation Update**: N/A — test file is self-documenting.

- **Verify**: `pnpm --filter @wave-client/vscode test` passes with all new test cases green.

---

## 6. Cross-Cutting Concerns

### Error Handling

All arena handlers follow the uniform `try/catch` pattern already established in
`MessageHandler`: on error, post a response with the same `type` plus `error: error.message`.
This means the webview's `sendAndWait` always resolves (never hangs), and the adapter layer
can surface the error to the user via `notification.showNotification('error', ...)`.

One exception: `handleArenaCancelChat` intentionally has no error handling — it is
fire-and-forget, and a missing `AbortController` is a no-op, not an error.

### Typed Narrowing vs `message: any`

The plan explicitly states: "new arena handlers should narrow the type immediately after the
switch dispatch." Each switch case casts the inbound `message` to its typed interface using
`message as ArenaXxxMsg`. This keeps the `handleMessage(message: any)` signature intact for
backward compat while ensuring all handler methods receive typed payloads.

### Logging

Per the plan's logging strategy:
- `console.info` on `arena.streamMessage` start: `sessionId`, `agent`, `provider`, `model`.
- `console.info` on `arena.cancelChat`: `sessionId`.
- `console.error` on streaming errors: provider name, error message (no API key, no request body).
- No logging for storage handlers (too noisy; storage errors are returned in the `error` field).

### Security

Provider settings payloads containing API keys (`arena.saveProviderSettings`,
`arena.loadProviderSettings`) must **never be logged**. The `console.info` calls for stream
start must log `{ sessionId, agent, provider, model }` only — not the full `chatRequest` which
includes `settings.apiKey`.

### AbortController Cleanup

`finally` in `handleArenaStreamMessage` ensures the `AbortController` is removed from the
map whether the stream completes normally, is aborted, or throws an error.

---

## 7. State Tracking

```
[FEAT-003]  Arena Message Handlers
  [TASK-001] Typed payload interfaces in services/types.ts          [ ] not-started
  [TASK-002] Storage CRUD handlers — sessions, messages, documents  [ ] not-started
  [TASK-003] Storage CRUD handlers — settings, references, provider [ ] not-started
  [TASK-004] Action + streaming handlers (stream, cancel, validate) [ ] not-started
  [TASK-005] Unit tests for all new handlers                        [ ] not-started
```
