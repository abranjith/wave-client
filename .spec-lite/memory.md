<!-- Generated by spec-lite v0.0.3 | sub-agent: memorize | updated: 2026-02-21 -->

# Memory — Standing Instructions

> These instructions are enforced across all sub-agent invocations.
> Memory is the **authoritative source** for coding standards, architecture, testing, logging, and security.
> Plans may contain plan-specific overrides but should not duplicate these rules.
> Managed by the Memorize sub-agent. Do not edit section headers manually.
> To add or change instructions, invoke: `/memorize <your instructions>`
> To override: `/memorize override <your instructions>`
> To generate from project analysis: `/memorize bootstrap`

## General

- Always ask for user confirmation before deleting any file. Verify it is not imported elsewhere before proceeding.
- When changing any existing file, be extra careful not to break existing functionality. Check component usages before making structural changes.
- Keep functions focused and single-responsibility. Extract reusable logic into custom hooks or utility functions.

## Tech Stack

- **Language**: TypeScript ^5.9 (strict mode). Target ES2022.
- **Frontend**: React ^19.1 with Tailwind CSS ^3.4.
- **Icons**: Lucide React ^0.543.
- **UI Primitives**: Radix UI (accordion, dialog, dropdown, select, tabs, tooltip, etc.) styled via Tailwind.
- **Build tools**: Vite (core, web packages); webpack 5 (vscode package).
- **Monorepo**: Turbo ^2.7 for build/task orchestration; pnpm ^10.26 with workspaces.
- **State management**: Zustand ^5 for global state; React Context + hooks for local component state.
- **HTTP**: axios ^1.11 (Node.js / vscode / server packages, supports proxies); fetch API (web package only).
- **Validation**: Zod ^3.25 — use for all schema validation at input boundaries.
- **Runtime**: Node.js 22.x (VS Code extension backend, server); browser (web/webview frontend).

## Project Structure

- Monorepo root at `wave-client/`. All packages live under `packages/`.
- `packages/core/` — platform-agnostic UI components, hooks, utilities, and types. Zero Node.js or browser-specific APIs. Built with Vite as a library; exports from `src/index.ts`.
- `packages/vscode/` — VS Code extension. Backend in `src/extension.ts`; webview entry in `src/webview/`. Compiled with webpack.
- `packages/web/` — standalone browser app. Entry at `src/main.tsx`.
- `packages/shared/` — shared services and types used by both vscode and server packages.
- `packages/server/` — HTTP server (REST API backend).
- `packages/mcp-server/` — MCP (Model Context Protocol) server.
- `packages/arena/` — Arena AI agent orchestration package.
- File naming: `kebab-case.ts` for general files; `PascalCase.tsx` for React component files.
- Component folders: `src/components/`, `src/hooks/`, `src/utils/`, `src/types/`, `src/config/`.
- Zustand state slices live in `packages/core/src/hooks/store/` — named `create<Domain>Slice.tsx`.
- Tests mirror source structure under `packages/core/src/test/` (e.g., `src/test/components/`, `src/test/hooks/`).

## Coding Standards

- Use strict TypeScript (`"strict": true`). Never use `any` unless explicitly justified with a comment.
- Use `unknown` + type narrowing instead of `any` for untyped inputs.
- Naming: `camelCase` for variables/functions, `PascalCase` for React components/classes/interfaces/types/enums, `UPPER_SNAKE_CASE` for module-level constants.
- Prefer `interface` over `type` for object shapes that may be extended. Use `type` for unions, intersections, and mapped types.
- Use `readonly` and `const` by default; mutate only when necessary.
- Prefer named exports over default exports, except for React page/component files where default export is conventional.
- Use `async/await` over raw Promises. Never mix callbacks with Promises.
- Never use `null` where `undefined` suffices. Be consistent within each package.
- Use `===` over `==` (ESLint `eqeqeq` is enforced).
- Always include semicolons (ESLint `semi` is warned).

## Architecture

- `packages/core` must contain **zero platform-specific code** — no `vsCodeApi`, no `localStorage`, no `fs`, no `window` APIs.
- All platform-specific I/O (HTTP, file system, storage, security, notifications) is delegated to adapters accessed via `useAdapter()` or the specific sub-hooks (`useStorageAdapter()`, `useHttpAdapter()`, `useNotificationAdapter()`, etc.).
- Each platform implements `IPlatformAdapter` (defined in `packages/core/src/types/adapters.ts`): `vsCodeAdapter` in vscode package, `webAdapter` in web package.
- Core components are wrapped in `<AdapterProvider adapter={...}>` at the platform entry point (`AppWithAdapter.tsx` for vscode, `main.tsx` for web).
- Zustand global state is the single source of truth for shared domain objects (collections, environments, history, etc.). Do not duplicate globally-tracked objects in local component state.
- Pass data via global state rather than prop-drilling when the data is already in the store.
- **All I/O operations** (HTTP requests to external APIs, file system access, data persistence) must be implemented via the **Service pattern on the server side** (`packages/server/` or `packages/shared/src/services/`), not performed directly on the client. This ensures consistent cross-platform handling and maximises reusability.
- **Do not mix HTTP client technologies within a layer.** Use `axios` exclusively in server-side and Node.js packages (vscode, server, shared). Never use different technologies within the same package for the same purpose.

## Design Patterns

- **Adapter Pattern**: All platform-specific I/O is behind the `IPlatformAdapter` interface. Core UI is 100% platform-agnostic.
- **Result Pattern**: All fallible operations return `Result<T, E>` — `{ isOk: true, value: T }` for success, `{ isOk: false, error: E }` for failure. Use `ok()` and `err()` helpers from `utils/result.ts`.
- **Service Pattern**: All I/O and business logic on the server side is encapsulated in service classes/functions under `src/services/`. Controllers and adapters delegate to services — never perform I/O directly.
- **Zustand Slice Pattern**: Global state is split into domain slices (`createCollectionsSlice`, `createEnvironmentsSlice`, etc.) composed in `useAppStateStore.tsx`.
- **Custom Hook Extraction**: Extract all non-trivial component logic into custom hooks (`use<Domain>.ts`).
- **Factory Pattern for Mocks**: Use `createMockAdapter(options)` from `packages/core/src/test/mocks/mockAdapter.ts` to build adapter mocks in tests.

## Error Handling

- All fallible adapter calls must use the `Result<T, E>` pattern. Never use bare `try/catch` around adapter calls.
- Check `result.isOk` before accessing `result.value`. Always handle the error branch.
- Show user-facing errors via `notification.showNotification('error', message)` — never via `alert()` or raw DOM.
- For truly exceptional/unexpected errors (e.g., initialization failures), use `try/catch` and log + surface to user.
- Do not swallow errors silently. At minimum, log with context before returning.

## Logging

- In **local development**, all client and server logs must be written to a local log file (e.g., `logs/dev.log` at the repo root) in addition to console output.
- A shell script (`scripts/tail-logs.sh` / `scripts/tail-logs.ps1`) must exist to output the last 100 lines of the log file. This script is the primary reference point for LLM/agent error diagnosis — always check it when investigating runtime errors.
- Log errors with sufficient context (what operation failed, relevant IDs/inputs) so that the tail output is actionable without additional context.
- Never log secrets, tokens, passwords, or PII.

## Testing

- **Framework**: Vitest + React Testing Library (`@testing-library/react`, `@testing-library/user-event`).
- **Environment**: jsdom (configured in `vitest.config.ts` per package).
- **Test location**: `packages/core/src/test/` mirroring source structure (e.g., `src/test/components/MyComponent.test.tsx`).
- **Naming**: Describe behavior, not methods — `it('shows error when request fails')` over `it('test handleSubmit')`.
- **Pattern**: Arrange-Act-Assert (AAA) in every test.
- **Mocking adapters**: Use `createMockAdapter()` from `packages/core/src/test/mocks/mockAdapter.ts`. Wrap component under test in `<AdapterProvider adapter={mockAdapter}>`.
- **Mocking functions**: Use `vi.fn()` for callbacks and stub functions.
- Assert on user-visible behavior (rendered text, buttons, ARIA roles) — not on implementation details or internal state.
- Write tests for all new functionality. Do not chase 100% coverage on trivial glue/wiring code.
- Run tests with `pnpm test` (all packages via Turbo) or `pnpm --filter @wave-client/core test` for a single package.

## Security

- Never call `vsCodeApi` directly from `packages/core` — only through the adapter.
- Store secrets and API keys via the `ISecretAdapter` (backed by VS Code's `SecretStorage` in the vscode package; Web Crypto in the web package). Never persist secrets in plain localStorage or in-memory state.
- Never commit secrets, tokens, or credentials to source control.
- Sanitize and validate all external input (API responses, user-provided strings) with Zod schemas before use.
- In the VS Code webview, enable only the minimum required capabilities (`enableScripts: true`, `retainContextWhenHidden: true`). Do not enable `allowInsecureContent`.

## Dependencies

- **Radix UI** — unstyled accessible UI primitives. Always style with Tailwind; do not override Radix with global CSS.
- **Zustand ^5** — global state management. One store per package, composed from slices.
- **axios ^1.11** — HTTP client for server-side/Node.js packages (vscode, server, shared). Supports proxies and interceptors.
- **Zod ^3.25** — schema validation for external/user input boundaries.
- **highlight.js ^11** — syntax highlighting for response bodies.
- **Lucide React ^0.543** — icon library. Do not add additional icon libraries.
- **class-variance-authority + clsx + tailwind-merge** — Tailwind class composition utilities. Use a `cn()` helper for conditional class merging.
- **Turbo ^2.7** — build orchestration. Define all cross-package tasks in `turbo.json`. Run builds/tests via `pnpm turbo <task>`.
- pnpm is the required package manager. Do not use npm or yarn.
- Keep devDependencies out of production bundles. Run `pnpm audit` periodically.

## Documentation

- All public functions, hooks, types, and React components must have JSDoc comments with `@param`, `@returns`, and an `@example` where helpful.
- Complex logic within functions must have inline comments explaining the "why", not just the "what".
- **Update relevant documentation** (README files, guides, architecture docs, CHANGELOG) as part of any feature or change that affects public APIs, architecture, or user-facing behaviour. Do not defer documentation to a later pass.
- Keep code self-documenting through clear, descriptive names — no abbreviations in exported identifiers.

## Performance

- Avoid unnecessary re-renders: memoize callbacks with `useCallback` and derived values with `useMemo` where re-render cost is non-trivial.
- Use proper dependency arrays in `useEffect`, `useCallback`, and `useMemo`.
- Debounce or throttle event handlers that fire frequently (e.g., input change, scroll).
- Batch related state updates where possible.
- Do not duplicate globally-tracked objects in local state — derive from the Zustand store instead.
