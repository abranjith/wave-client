<!-- Generated by spec-lite v0.0.4 | sub-agent: planner | date: 2026-02-21 -->

# Plan: Arena Backend Migration — Move LLM I/O to Extension Host

## 1. Overview

Wave Client's Arena AI chat feature currently performs all LLM calls directly from the webview  
(`vsCodeArenaAdapter.ts`), bypassing the `@wave-client/arena` LangGraph agents entirely and  
exposing provider settings to the browser process. This plan migrates all Arena I/O — LLM  
inference, real streaming, agent execution, and persistent storage — to the VS Code extension  
host backend, in line with the established architecture rule: all I/O belongs on the server side.  
The webview becomes a thin relay: it sends requests over `postMessage`, receives streaming chunks  
as push events, and renders results. The real LangGraph agents (`WaveClientAgent`, `WebExpertAgent`)  
are wired up for the first time. Sessions, messages, document metadata, references, and provider  
settings (including API keys) are persisted to disk under `.waveclient/arena/`.

**Scope**: VS Code package only. `webArenaAdapter` (packages/web) is not affected.

---

## 2. High-Level Features

1. **ArenaStorageService** — On-disk persistence for all Arena data under `.waveclient/arena/`.
2. **ArenaService** — Extension-host LLM execution engine: provider factory, real LangGraph agent  
   wiring, true streaming via `AsyncIterable`, cancellation via `AbortController`.
3. **Arena message handlers** — New message routing cases in `MessageHandler.ts` covering all  
   arena operations, plus a streaming push protocol for chat.
4. **Updated vsCodeArenaAdapter** — All in-memory state and direct `fetch` calls removed;  
   everything delegates to the extension host via `postMessage`.

---

## 3. Tech Stack Additions

> The canonical tech stack is defined in `.spec-lite/memory.md` → Tech Stack.

| Component | Technology | Justification |
|-----------|-----------|---------------|
| LangGraph agent streaming | `@wave-client/arena` (already a workspace dep) | The package already has working `AsyncGenerator`-based streaming in `WaveClientAgent.chat()`. This plan activates it. |
| LLM HTTP calls | LangChain/LangGraph internal (axios under the hood) | The LangGraph providers manage their own HTTP; no change to `HttpService` is needed. |

---

## 4. Data Model (High-Level)

### Domain Concepts

- **ArenaSession**: A named conversation thread, with an active agent and timestamps. Has many messages.
- **ArenaMessage**: A single turn (user, assistant, tool) within a session, referencing its parent session by ID.
- **ArenaDocument**: Metadata for a user-uploaded document (filename, MIME type, size, processed flag). Actual file content stored as `.waveclient/arena/documents/{id}`.
- **ArenaReference**: A user-curated URL/document reference for the WebExpert agent.
- **ArenaProviderSettings**: Per-provider configuration such as API key (Gemini), base URL (Ollama), selected model, and disabled models. Treated as settings (not secrets) per project convention.
- **ArenaSettings**: Global arena settings (active provider, temperature, context window, etc.).

### Conceptual Relationships

- `ArenaSession` → `ArenaMessage`: one-to-many; messages stored per-session.
- `ArenaSession` → `ArenaDocument`: many-to-many (a session may reference uploaded documents).
- `ArenaProviderSettings` → `ArenaSettings`: provider settings are subordinate to the global settings record.

### Storage Strategy

Flat JSON files under `.waveclient/arena/` (mirrors existing `CollectionService` / `EnvironmentService` pattern in `packages/shared/src/services/`):

```
.waveclient/arena/
  sessions.json            ← ArenaSession[] (no messages inline)
  messages/
    {sessionId}.json       ← ArenaMessage[] for that session
  documents.json           ← ArenaDocument[] (metadata only)
  documents/
    {documentId}           ← raw uploaded file content
  references.json          ← ArenaReference[]
  provider-settings.json   ← ArenaProviderSettingsMap (includes API keys as plain text per user decision)
  settings.json            ← ArenaSettings (global)
```

---

## 5. Interface Design

### 5a. New Service: `ArenaStorageService` (`packages/shared/src/services/ArenaStorageService.ts`)

Public API surface (all methods return `Promise<T>`; throw on unexpected FS errors):

```typescript
class ArenaStorageService {
  loadSessions(): Promise<ArenaSession[]>
  saveSession(session: ArenaSession): Promise<void>
  deleteSession(sessionId: string): Promise<void>
  loadMessages(sessionId: string): Promise<ArenaMessage[]>
  saveMessages(sessionId: string, messages: ArenaMessage[]): Promise<void>
  clearSessionMessages(sessionId: string): Promise<void>
  loadDocuments(): Promise<ArenaDocument[]>
  saveDocumentMetadata(document: ArenaDocument): Promise<void>
  deleteDocument(documentId: string): Promise<void>
  loadDocumentContent(documentId: string): Promise<Buffer>
  saveDocumentContent(documentId: string, content: Buffer): Promise<void>
  loadReferences(): Promise<ArenaReference[]>
  saveReferences(references: ArenaReference[]): Promise<void>
  loadProviderSettings(): Promise<ArenaProviderSettingsMap>
  saveProviderSettings(settings: ArenaProviderSettingsMap): Promise<void>
  loadSettings(): Promise<ArenaSettings>
  saveSettings(settings: ArenaSettings): Promise<void>
}
```

Export a singleton `arenaStorageService` alongside the instance (same pattern as `collectionService`).

### 5b. New Service: `ArenaService` (`packages/vscode/src/services/ArenaService.ts`)

```typescript
class ArenaService {
  /** Start a streaming chat. Calls onChunk per token. Returns full response when done. */
  streamChat(
    request: ArenaChatRequest,
    onChunk: (chunk: ArenaChatStreamChunk) => void,
    signal: AbortSignal
  ): Promise<ArenaChatResponse>

  /** Non-streaming chat (delegates to streamChat, collects chunks). */
  sendChat(request: ArenaChatRequest, signal: AbortSignal): Promise<ArenaChatResponse>

  /** Validate a provider's API key/connectivity. */
  validateApiKey(provider: string, apiKey: string, baseUrl?: string): Promise<boolean>

  /** Dynamically list available models (e.g. Ollama tags). */
  getAvailableModels(provider: string): Promise<{ id: string; label: string }[]>
}
```

Internally, `ArenaService`:
- Reads provider settings from `arenaStorageService` to get API keys / base URLs.
- Creates the LLM provider via `createProviderFactory` from `@wave-client/arena`.
- Selects the agent based on `request.agent`:
  - `ARENA_AGENT_IDS.WAVE_CLIENT` → `createWaveClientAgent` (with MCP bridge tools if mcp-server is configured)
  - `ARENA_AGENT_IDS.WEB_EXPERT` → `createWebExpertAgent`
  - fallback → raw LLM invoke (no tools)
- Iterates the `AsyncGenerator` from `agent.chat()`, emitting chunks via `onChunk`.
- Respects the `AbortSignal` by wrapping the generator loop.

Export a singleton `arenaService`.

### 5c. Arena Message Protocol (webview ↔ extension host)

All arena messages follow the existing `{ type, requestId, ...data }` postMessage convention  
already used throughout `MessageHandler.ts`.

#### Request → Response messages (all use `sendAndWait<T>` in the adapter)

| Webview → Extension type | Payload fields | Extension → Webview response type | Response data field |
|---|---|---|---|
| `arena.loadSessions` | — | `arena.loadSessions` | `sessions` |
| `arena.saveSession` | `session` | `arena.saveSession` | — |
| `arena.deleteSession` | `sessionId` | `arena.deleteSession` | — |
| `arena.loadMessages` | `sessionId` | `arena.loadMessages` | `messages` |
| `arena.saveMessage` | `message` | `arena.saveMessage` | — |
| `arena.clearSessionMessages` | `sessionId` | `arena.clearSessionMessages` | — |
| `arena.loadDocuments` | — | `arena.loadDocuments` | `documents` |
| `arena.uploadDocument` | `metadata`, `contentBase64` | `arena.uploadDocument` | `document` |
| `arena.deleteDocument` | `documentId` | `arena.deleteDocument` | — |
| `arena.loadSettings` | — | `arena.loadSettings` | `settings` |
| `arena.saveSettings` | `settings` | `arena.saveSettings` | — |
| `arena.loadReferences` | — | `arena.loadReferences` | `references` |
| `arena.saveReferences` | `references` | `arena.saveReferences` | — |
| `arena.loadProviderSettings` | — | `arena.loadProviderSettings` | `settings` |
| `arena.saveProviderSettings` | `settings` | `arena.saveProviderSettings` | — |
| `arena.validateApiKey` | `provider`, `apiKey`, `baseUrl?` | `arena.validateApiKey` | `valid` |
| `arena.getAvailableModels` | `provider` | `arena.getAvailableModels` | `models` |

#### Streaming protocol (`arena.streamMessage`)

This is the only message type that uses a push/stream response pattern:

```
Webview → Extension:  { type: 'arena.streamMessage', requestId, chatRequest }

  [for each token]
Extension → Webview:  { type: 'arena.streamChunk',   sessionId, chunk: ArenaChatStreamChunk }

  [on success]
Extension → Webview:  { type: 'arena.streamComplete', requestId, response: ArenaChatResponse }

  [on error]
Extension → Webview:  { type: 'arena.streamError',    requestId, error: string }

Webview → Extension:  { type: 'arena.cancelChat',     sessionId }   ← fire-and-forget, no requestId
```

`arena.streamChunk` is a **push event** (no `requestId`). The vsCodeAdapter routes it onto the  
existing `IAdapterEvents` event bus as `'arenaStreamChunk'`. The adapter's `streamMessage`  
implementation temporarily subscribes to `'arenaStreamChunk'` events on the bus and calls  
`onChunk` for each one; it resolves the wrapping `sendAndWait` promise only when  
`arena.streamComplete` (or `arena.streamError`) arrives with the matching `requestId`.

### 5d. MessageHandler additions (`packages/vscode/src/handlers/MessageHandler.ts`)

New `switch` cases:

```
'arena.loadSessions'       → arenaStorageService.loadSessions()
'arena.saveSession'        → arenaStorageService.saveSession(message.session)
'arena.deleteSession'      → arenaStorageService.deleteSession(message.sessionId)
'arena.loadMessages'       → arenaStorageService.loadMessages(message.sessionId)
'arena.saveMessage'        → arenaStorageService.saveMessages(...) [merge + persist]
'arena.clearSessionMessages' → arenaStorageService.clearSessionMessages(message.sessionId)
'arena.loadDocuments'      → arenaStorageService.loadDocuments()
'arena.uploadDocument'     → arenaStorageService.saveDocumentContent() + saveDocumentMetadata()
'arena.deleteDocument'     → arenaStorageService.deleteDocument()
'arena.loadSettings'       → arenaStorageService.loadSettings()
'arena.saveSettings'       → arenaStorageService.saveSettings(message.settings)
'arena.loadReferences'     → arenaStorageService.loadReferences()
'arena.saveReferences'     → arenaStorageService.saveReferences(message.references)
'arena.loadProviderSettings' → arenaStorageService.loadProviderSettings()
'arena.saveProviderSettings' → arenaStorageService.saveProviderSettings(message.settings)
'arena.validateApiKey'     → arenaService.validateApiKey(...)
'arena.getAvailableModels' → arenaService.getAvailableModels(message.provider)
'arena.streamMessage'      → arenaService.streamChat(...) with per-chunk postMessage push
'arena.cancelChat'         → arenaService.cancelChat(message.sessionId) [AbortController.abort()]
```

For `arena.streamMessage`, the handler:
1. Creates an `AbortController` keyed to `message.chatRequest.sessionId`.
2. Calls `arenaService.streamChat(chatRequest, onChunk, controller.signal)`.
3. `onChunk` calls `this.postMessage({ type: 'arena.streamChunk', sessionId, chunk })`.
4. On completion: `this.postMessage({ type: 'arena.streamComplete', requestId, response })`.
5. On error: `this.postMessage({ type: 'arena.streamError', requestId, error })`.
6. On completion, deletes the AbortController keyed entry.

### 5e. Updated vsCodeArenaAdapter (`packages/vscode/src/webview/adapters/vsCodeArenaAdapter.ts`)

**Remove completely:**
- `localSessions`, `localMessages`, `localDocuments`, `localSettings`, `localReferences`, `localProviderSettings` in-memory state
- `saveState()` and `vsCodeApi.getState()`/`setState()` machinery for arena data
- `sendGeminiMessage()`, `sendOllamaMessage()` functions
- `getSystemPromptForAgent()` helper (now lives in the extension host)
- All direct `fetch()` calls

**Replace `streamMessage` with:**
```typescript
async streamMessage(request, onChunk): Promise<Result<ArenaChatResponse, string>> {
  // Subscribe to push chunks BEFORE sending the request
  const subscription = events.on('arenaStreamChunk', (chunk) => {
    if (chunk.messageId === expectedMessageId) onChunk(chunk);
  });
  const result = await sendAndWait<ArenaChatResponse>('arena.streamMessage', { chatRequest: request });
  subscription.unsubscribe();            // clean up listener
  return result;
}
```

`cancelChat` is a fire-and-forget postMessage (no `sendAndWait`).

**The `responseDataMap` in `sendAndWait` is extended** with all new arena message types.

---

## 6. Security Considerations

> Standing security rules are defined in `.spec-lite/memory.md` → Security.

- API keys are stored in `provider-settings.json` as plain text (per user decision — same treatment as existing settings files). This is acceptable given `.waveclient/` is a local developer workspace directory. A future plan should migrate to `SecretStorage`.
- Provider settings (including API keys) must **never be logged** in compliance with the memory rule "Never log secrets".
- Document upload content is base64-encoded for the `postMessage` transfer boundary; the extension host decodes and stores as a raw Buffer.

---

## 7. Architecture & Design (Plan-Specific)

### Plan-Specific Decisions

- **Streaming via postMessage push + event bus relay**: LangGraph's `AsyncGenerator` runs in the extension host. Each yielded `ChatChunk` is forwarded to the webview as a push `arena.streamChunk` postMessage (no requestId). The vsCodeAdapter bridges these to the `IAdapterEvents` event bus, which is what `ArenaPane` already subscribes to via `'arenaStreamChunk'` events. The final `arena.streamComplete` carries the requestId to resolve the `sendAndWait` promise. This avoids introducing a second communication channel while keeping the streaming reactive.

- **AbortController per session**: `MessageHandler` maintains a `Map<sessionId, AbortController>`. `arena.cancelChat` calls `abort()` on the matching controller. The `ArenaService.streamChat()` generator loop checks `signal.aborted` at each iteration before proceeding to the next chunk.

- **ArenaService does not extend `HttpService`**: LangGraph providers manage their own HTTP internally. `HttpService` remains a request/response engine for REST calls only. The two concerns are kept separate.

- **ArenaStorageService lives in `packages/shared`**: This follows the precedent of `CollectionService`, `EnvironmentService`, etc. The `packages/vscode/src/services/` layer then re-exports or wraps it, keeping the dependency flow consistent (`vscode` → `shared` → no platform-specific APIs).

- **No changes to `IArenaAdapter` interface**: The `IArenaAdapter` contract already models the right operations. Only the implementation (`vsCodeArenaAdapter`) changes. The `webArenaAdapter` (packages/web) is untouched.

- **Agent selection in ArenaService**: Agent type is determined by `request.agent` field (already part of `ArenaChatRequest`). The service keeps a cache of compiled LangGraph apps keyed by `${provider}:${model}:${agent}` to avoid recompiling the graph on every message.

---

## 8. Coding Standards (Plan-Specific Overrides)

> No overrides — see memory.

One addendum: **`any` is strictly forbidden in the new services**. The current `MessageHandler` uses `message: any` for backward compatibility; new arena handlers should narrow the type immediately after the switch dispatch using typed interfaces defined in `services/types.ts` (already exists in `packages/vscode/src/services/types.ts`).

---

## 9. Testing Strategy (Plan-Specific)

> Standing testing conventions are in `.spec-lite/memory.md` → Testing.

- **`ArenaStorageService` unit tests** (`packages/shared/src/test/services/ArenaStorageService.test.ts`):  
  Mock the file system using `vi.mock('fs')` or a temp directory fixture. Test round-trip persistence for each entity type (sessions, messages, documents, references, provider settings, settings). Test missing-file defaults (first run with no existing `.waveclient/arena/` directory).

- **`ArenaService` unit tests** (`packages/vscode/src/test/services/ArenaService.test.ts`):  
  Mock the `@wave-client/arena` providers and agent factories. Assert that the correct agent is selected per `request.agent`. Assert that chunks are forwarded via the `onChunk` callback. Assert that `AbortSignal` termination stops the generator early and does not call `onChunk` after abort.

- **`vsCodeArenaAdapter` unit tests** (`packages/vscode/src/test/adapters/vsCodeArenaAdapter.test.ts`):  
  Mock `vsCodeApi.postMessage`. Assert that storage methods send the correct message types. Assert that `streamMessage` subscribes to `arenaStreamChunk` events before sending the request and unsubscribes after completion. Assert that `cancelChat` sends a fire-and-forget postMessage.

- **Integration**: Manually verify end-to-end streaming in the extension host by running the extension in the Extension Development Host and chatting with both Gemini and Ollama agents.

---

## 10. Logging Strategy (Plan-Specific)

> Standing logging conventions are in `.spec-lite/memory.md` → Logging.

- Log `arena.streamMessage` start (sessionId, agent, provider, model) at INFO level.
- Log each `arena.cancelChat` at INFO level (sessionId).
- Log LLM provider errors (non-2xx from Gemini/Ollama) at ERROR level with provider name and status code — **never include the API key or request body**.
- Log `ArenaStorageService` file I/O errors at ERROR level with file path and operation.

---

## Files Changed / Created

| Path | Action |
|---|---|
| `packages/shared/src/services/ArenaStorageService.ts` | **Create** |
| `packages/shared/src/services/index.ts` | **Update** — export `arenaStorageService` |
| `packages/vscode/src/services/ArenaService.ts` | **Create** |
| `packages/vscode/src/services/index.ts` | **Update** — export `arenaService` |
| `packages/vscode/src/services/types.ts` | **Update** — add typed arena message payload interfaces |
| `packages/vscode/src/handlers/MessageHandler.ts` | **Update** — add arena switch cases + streaming handler |
| `packages/vscode/src/webview/adapters/vsCodeArenaAdapter.ts` | **Update** — remove local state + fetch calls, delegate to extension host |
| `packages/vscode/src/webview/adapters/vsCodeAdapter.ts` | **Update** — add routing for `arena.streamChunk` push event to `IAdapterEvents` |

---

## Out of Scope for This Plan

- Web adapter (`packages/web`) — unchanged.
- Document embedding / RAG / vector store activation.
- SecretStorage migration for API keys (tracked as a future enhancement).
- New agent types beyond `WaveClientAgent` and `WebExpertAgent`.
- MCP bridge wiring for `WaveClientAgent` tools (agent is created, tools array is passed empty initially; MCP bridge is a separate plan).
